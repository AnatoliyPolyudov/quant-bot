

===== baseline_strategy.py =====


# baseline_strategy.py
class BaselineStrategy:
    def __init__(self):
        self.min_imbalance = 0.55  # üîß –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–π —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        self.min_delta = 3         # üîß –£–º–µ–Ω—å—à–µ–Ω–æ
        self.max_spread = 0.03
        self.max_volatility = 0.5  # üîß –î–û–ë–ê–í–õ–ï–ù–û: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
        
    def analyze_signal(self, features):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ñ–∏—á–∏ —Å —É—á–µ—Ç–æ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏"""
        imbalance = features.get('order_book_imbalance', 0.5)
        delta = features.get('cumulative_delta', 0)
        spread = features.get('spread_percent', 0)
        funding = features.get('funding_rate', 0)
        volatility = features.get('volatility', 0)  # üîß –ù–û–í–ê–Ø –§–ò–ß–ê
        
        signals = []
        
        # –ü—Ä–∞–≤–∏–ª–æ 1: Imbalance
        if imbalance > self.min_imbalance:
            signals.append(f"üìä Imbalance {imbalance:.3f} > {self.min_imbalance}")
        
        # –ü—Ä–∞–≤–∏–ª–æ 2: Delta
        if delta > self.min_delta:
            signals.append(f"üìà Delta {delta:.1f} > {self.min_delta}")
        
        # –ü—Ä–∞–≤–∏–ª–æ 3: Spread
        if spread < self.max_spread:
            signals.append(f"üìè Spread {spread:.4f}% < {self.max_spread}%")
        else:
            signals.append(f"‚ùå Spread {spread:.4f}% —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫")
        
        # üîß –ü–†–ê–í–ò–õ–û 4: –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
        if volatility < self.max_volatility:
            signals.append(f"üìä Volatility {volatility:.3f}% < {self.max_volatility}%")
        else:
            signals.append(f"‚ö° Volatility {volatility:.3f}% —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–∞")
        
        # –ü—Ä–∞–≤–∏–ª–æ 5: Funding
        if abs(funding) < 0.0001:
            signals.append("üí∞ Funding –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π")
        else:
            signals.append(f"‚ö†Ô∏è Funding {funding:.6f}")
        
        # üîß –£–õ–£–ß–®–ï–ù–ù–û–ï –ø—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è
        buy_signal = (imbalance > self.min_imbalance and 
                     delta > self.min_delta and 
                     spread < self.max_spread and
                     volatility < self.max_volatility)  # üîß –£—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
        
        sell_signal = (imbalance < (1 - self.min_imbalance) and 
                      delta < -self.min_delta and 
                      spread < self.max_spread and
                      volatility < self.max_volatility)  # üîß –£—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
        
        if buy_signal:
            decision = "LONG"
            # üîß –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
            base_confidence = min(imbalance * 100, 95)
            vol_penalty = max(0, (volatility / self.max_volatility) * 20)
            confidence = max(0, base_confidence - vol_penalty)
        elif sell_signal:
            decision = "SHORT" 
            base_confidence = min((1 - imbalance) * 100, 95)
            vol_penalty = max(0, (volatility / self.max_volatility) * 20)
            confidence = max(0, base_confidence - vol_penalty)
        else:
            decision = "HOLD"
            confidence = 0
        
        return {
            'decision': decision,
            'confidence': confidence,
            'signals': signals,
            'imbalance': imbalance,
            'delta': delta,
            'spread': spread,
            'volatility': volatility  # üîß –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –≤—ã–≤–æ–¥
        }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
baseline_strategy = BaselineStrategy()


===== config.py =====


# config.py

# Trading settings
SYMBOL = "BTC-USDT-SWAP"
TIMEFRAME = "1m"

# Data collection
WS_URL = "wss://ws.okx.com:8443/ws/v5/public"
CHANNELS = [
    "books",              # –°—Ç–∞–∫–∞–Ω L2
    "trades",             # –õ–µ–Ω—Ç–∞ —Å–¥–µ–ª–æ–∫
    "tickers"             # –¢–∏–∫–µ—Ä—ã (funding, OI)
]

# Feature settings
FEATURE_WINDOW = 50

# Model settings
MIN_PROBABILITY = 0.65


===== data_collector.py =====


# data_collector.py
import websocket
import json
import threading
import time
from datetime import datetime
from feature_engine import feature_engine
from data_logger import data_logger
from baseline_strategy import baseline_strategy

class OKXDataCollector:
    def __init__(self):
        self.ws = None
        self.data_buffer = []
        self.message_count = 0
        self.last_feature_print = 0
        self.last_data_log = 0
        
        # –†–∞–∑–¥–µ–ª—å–Ω—ã–µ –±—É—Ñ–µ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
        self.order_book_data = []
        self.trade_data = []
        self.ticker_data = []
        
    def on_message(self, ws, message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            data = json.loads(message)
            self.message_count += 1
            
            # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–µ—Ä–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            if self.message_count <= 3:
                print(f"\nüîç RAW MESSAGE #{self.message_count}:")
                print(f"   Keys: {list(data.keys())}")
                if 'arg' in data:
                    print(f"   Channel: {data['arg']}")
                if 'data' in data:
                    print(f"   Data length: {len(data['data'])}")
                    if len(data['data']) > 0:
                        print(f"   First item keys: {list(data['data'][0].keys())}")
                        print(f"   Sample: {str(data['data'][0])[:200]}...")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
            if 'event' in data:
                if data['event'] != 'subscribe':  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏
                    print(f"‚ö° Event: {data['event']} - {data.get('msg', '')}")
            elif 'data' in data:
                channel = data.get('arg', {}).get('channel', 'unknown')
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –±—É—Ñ–µ—Ä—ã
                if channel == 'books':
                    self.order_book_data = data['data']
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å—Ç–∞–∫–∞–Ω–∞
                    if self.message_count <= 3 and len(data['data']) > 0:
                        book = data['data'][0]
                        print(f"   üìö Order Book - Bids: {len(book.get('bids', []))}, Asks: {len(book.get('asks', []))}")
                        
                elif channel == 'trades':
                    self.trade_data = data['data']
                    if self.message_count <= 3 and len(data['data']) > 0:
                        trade = data['data'][0]
                        print(f"   üí∞ Trade - Side: {trade.get('side')}, Size: {trade.get('sz')}")
                        
                elif channel == 'tickers':
                    self.ticker_data = data['data']
                    if self.message_count <= 3 and len(data['data']) > 0:
                        ticker = data['data'][0]
                        print(f"   üìà Ticker - Last: {ticker.get('last')}, Funding: {ticker.get('fundingRate')}")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏—á–∏ –∏ –≤—ã–≤–æ–¥–∏–º/–ª–æ–≥–∏—Ä—É–µ–º
                self.update_features()
                
        except Exception as e:
            print(f"‚ùå Message error: {e}")
    
    def update_features(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ñ–∏—á–∏ –∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤—ã–≤–æ–¥–æ–º/–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        current_time = time.time()
        
        # –í—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏—á–∏
        features = feature_engine.get_all_features(
            self.order_book_data, 
            self.trade_data, 
            self.ticker_data
        )
        
        # –ê–Ω–∞–ª–∏–∑ –±–µ–π–∑–ª–∞–π–Ω-—Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
        strategy_result = baseline_strategy.analyze_signal(features)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ (–ª–æ–≥–∏–∫–∞ —Ç–µ–ø–µ—Ä—å –≤ data_logger)
        data_logger.log_features(features)
        
        # –í—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥ (—á–∞—â–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
        if current_time - self.last_feature_print > 10:
            self.last_feature_print = current_time
            
            print("\n" + "="*50)
            print(f"üéØ REAL-TIME FEATURES (Msg #{self.message_count})")
            print("="*50)
            
            print(f"üìä Order Book Imbalance: {features['order_book_imbalance']:.3f}")
            print(f"üìè Spread: {features['spread_percent']:.6f}%")
            print(f"üìà Cumulative Delta: {features['cumulative_delta']:.4f}")
            print(f"üí∞ Funding Rate: {features['funding_rate']:.8f}")
            print(f"üîÑ Trades: {features['buy_trades']} buy / {features['sell_trades']} sell")
            print(f"üíµ Current Price: {features['current_price']}")
            
            print(f"\nü§ñ BASELINE DECISION: {strategy_result['decision']}")
            print(f"üéØ Confidence: {strategy_result['confidence']:.1f}%")
            
            for signal in strategy_result['signals']:
                print(f"   {signal}")
                
            print(f"üìä Data buffers - OB: {len(self.order_book_data)}, Trades: {len(self.trade_data)}, Ticker: {len(self.ticker_data)}")
            print("="*50 + "\n")
    
    def on_error(self, ws, error):
        print(f"‚ùå WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("üîå WebSocket closed")
        # –ê–≤—Ç–æ–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        time.sleep(5)
        self.start()
    
    def on_open(self, ws):
        print(f"üîå WebSocket connected at {datetime.now()}")
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–∞–Ω–∞–ª—ã
        from config import CHANNELS, SYMBOL
        for channel in CHANNELS:
            subscribe_msg = {
                "op": "subscribe",
                "args": [
                    {
                        "channel": channel,
                        "instId": SYMBOL
                    }
                ]
            }
            ws.send(json.dumps(subscribe_msg))
            print(f"üì° Subscribed to: {channel} for {SYMBOL}")
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
        from config import WS_URL
        
        self.ws = websocket.WebSocketApp(
            WS_URL,
            on_message=self.on_message,
            on_error=self.on_error, 
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        self.ws_thread = threading.Thread(target=self.ws.run_forever)
        self.ws_thread.daemon = True
        self.ws_thread.start()
        print("üöÄ Data collector started")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –í –ö–û–ù–¶–ï –§–ê–ô–õ–ê
data_collector = OKXDataCollector()


===== data_logger.py =====


# data_logger.py
import csv
import os
import time
from datetime import datetime

class DataLogger:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        self.setup_data_file()
        self.logged_count = 0
        self.last_log_time = 0
        self.log_interval = 5
        self.anomaly_count = 0
        
    def setup_data_file(self):
        os.makedirs("data", exist_ok=True)
        if not os.path.exists(self.data_file):
            with open(self.data_file, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow([
                    'timestamp',
                    'order_book_imbalance', 
                    'spread_percent',
                    'cumulative_delta',
                    'funding_rate',
                    'buy_trades',
                    'sell_trades',
                    'total_trades',
                    'current_price',
                    'volatility',  # üîß –î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è —Ñ–∏—á–∞
                    'target'
                ])
    
    def is_valid_features(self, features):
        try:
            spread = features.get('spread_percent', 0)
            if spread > 1.0:
                return False
            
            imbalance = features.get('order_book_imbalance', 0.5)
            if imbalance < 0 or imbalance > 1:
                return False
            
            price = features.get('current_price', 0)
            if price < 1000 or price > 200000:
                return False
            
            delta = abs(features.get('cumulative_delta', 0))
            if delta > 10000:
                return False
            
            return True
            
        except Exception as e:
            return False
    
    def log_features(self, features):
        try:
            current_time = time.time()
            
            if not self.is_valid_features(features):
                return
            
            if current_time - self.last_log_time >= self.log_interval:
                self.last_log_time = current_time
                self.logged_count += 1
                
                with open(self.data_file, 'a', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow([
                        features['timestamp'],
                        features['order_book_imbalance'],
                        features['spread_percent'],
                        features['cumulative_delta'],
                        features['funding_rate'],
                        features['buy_trades'],
                        features['sell_trades'],
                        features['total_trades'],
                        features['current_price'],
                        features.get('volatility', 0),  # üîß –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
                        features.get('target', 0)
                    ])
                
                target_val = features.get('target', 0)
                
                if target_val != 0:
                    if target_val == 1:
                        target_symbol = "üü¢"
                    elif target_val == -1:
                        target_symbol = "üî¥"
                    else:
                        target_symbol = "‚ö™"
                    
                    print(f"üíæ {target_symbol} SAVED #{self.logged_count}: target={target_val}")
                
        except Exception as e:
            pass

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
data_logger = DataLogger()


===== data_monitor.py =====


# data_monitor.py
import os
import csv
from datetime import datetime
import time

class DataMonitor:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        
    def check_data_progress(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ pandas"""
        if not os.path.exists(self.data_file):
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'NO_DATA'
            }
        
        try:
            total_records = 0
            labeled_records = 0
            target_dist = {-1: 0, 0: 0, 1: 0}
            
            with open(self.data_file, 'r') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    total_records += 1
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º target
                    if 'target' in row and row['target'].strip():
                        try:
                            target_val = int(row['target'])
                            labeled_records += 1
                            if target_val in [-1, 0, 1]:
                                target_dist[target_val] += 1
                        except ValueError:
                            pass
            
            # –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
            if labeled_records == 0 and total_records > 0:
                quality = 'COLLECTING'
            elif labeled_records < 50:
                quality = 'MINIMAL'
            elif labeled_records < 200:
                quality = 'GOOD'
            else:
                quality = 'EXCELLENT'
                
            # –£–±–∏—Ä–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            target_dist = {k: v for k, v in target_dist.items() if v > 0}
            
            return {
                'total_records': total_records,
                'labeled_records': labeled_records,
                'target_distribution': target_dist,
                'data_quality': quality
            }
            
        except Exception as e:
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'ERROR'
            }
    
    def print_progress_report(self):
        """–í—ã–≤–æ–¥–∏—Ç –æ—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ"""
        progress = self.check_data_progress()
        
        print("\n" + "="*60)
        print("üìä –û–¢–ß–ï–¢ –û –°–ë–û–†–ï –î–ê–ù–ù–´–•")
        print("="*60)
        
        print(f"üìÅ –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {progress['total_records']}")
        print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {progress['labeled_records']}")
        print(f"üìà –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality']}")
        
        if progress['target_distribution']:
            print(f"üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target: {progress['target_distribution']}")
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if progress['data_quality'] == 'NO_DATA':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö")
        elif progress['data_quality'] == 'COLLECTING':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –î–∞–Ω–Ω—ã–µ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è, target —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç")
        elif progress['data_quality'] == 'MINIMAL':
            records_needed = 50 - progress['labeled_records']
            print(f"üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –°–æ–±–µ—Ä–∏—Ç–µ –µ—â–µ {records_needed} –∑–∞–ø–∏—Å–µ–π –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
        elif progress['data_quality'] == 'GOOD':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏!")
        elif progress['data_quality'] == 'EXCELLENT':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –û—Ç–ª–∏—á–Ω—ã–π –æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è!")
        
        print("="*60)

def monitor_continuous():
    """–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
    monitor = DataMonitor()
    
    print("üöÄ –ó–ê–ü–£–°–ö –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –î–ê–ù–ù–´–•...")
    print("üí° –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥")
    print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
    
    try:
        while True:
            monitor.print_progress_report()
            time.sleep(30)
    except KeyboardInterrupt:
        print("\nüõë –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

if __name__ == "__main__":
    monitor_continuous()


===== feature_engine.py =====


# feature_engine.py
from datetime import datetime, timedelta
import time
import numpy as np

class FeatureEngine:
    def __init__(self):
        self.cumulative_delta = 0
        self.trade_counts = {'buy': 0, 'sell': 0}
        self.price_history = []
        self.feature_history = []
        self.last_update_time = 0
        self.update_interval = 1
        self.last_history_debug = 0
        self.target_horizon = 8        # üîß –£–º–µ–Ω—å—à–µ–Ω–æ –¥–æ 8 —Å–µ–∫—É–Ω–¥
        self.target_threshold = 0.01   # üîß –£–º–µ–Ω—å—à–µ–Ω–æ –¥–æ 0.01%
        self.trade_history = []
        self.volatility_window = 30
        self.ob_debug_shown = False
        
    def calculate_order_book_imbalance(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç imbalance –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0.5
                
            book = order_book_data[0]
            
            if 'bids' not in book or 'asks' not in book:
                return 0.5
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0.5
                
            bids = book['bids']
            asks = book['asks']
            
            bid_levels = min(len(bids), 3)
            ask_levels = min(len(asks), 3)
            
            if bid_levels == 0 or ask_levels == 0:
                return 0.5
            
            valid_bids = [bid for bid in bids[:bid_levels] if len(bid) >= 2 and float(bid[1]) > 0]
            valid_asks = [ask for ask in asks[:ask_levels] if len(ask) >= 2 and float(ask[1]) > 0]
            
            if not valid_bids or not valid_asks:
                return 0.5
            
            bid_volume = sum(float(bid[1]) for bid in valid_bids)
            ask_volume = sum(float(ask[1]) for ask in valid_asks)
            
            total_volume = bid_volume + ask_volume
            if total_volume == 0:
                return 0.5
                
            imbalance = bid_volume / total_volume
            imbalance = max(0.01, min(0.99, imbalance))
            
            return imbalance
            
        except Exception as e:
            return 0.5
    
    def calculate_spread(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–ø—Ä–µ–¥"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0.1
                
            book = order_book_data[0]
            
            if 'bids' not in book or 'asks' not in book:
                return 0.1
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0.1
            
            if len(book['bids'][0]) < 1 or len(book['asks'][0]) < 1:
                return 0.1
                
            best_bid = float(book['bids'][0][0])
            best_ask = float(book['asks'][0][0])
            
            if best_bid <= 0 or best_ask <= 0:
                return 0.1
                
            if best_bid >= best_ask:
                return 0.1
                
            spread = best_ask - best_bid
            mid_price = (best_bid + best_ask) / 2
            spread_percent = (spread / mid_price) * 100
            
            if spread_percent < 0 or spread_percent > 1.0:
                return 0.1
                
            return spread_percent
            
        except Exception as e:
            return 0.1
    
    def update_cumulative_delta(self, trade_data):
        """Rolling delta –∑–∞ 20 —Å–µ–∫—É–Ω–¥"""
        try:
            current_time = time.time()
            
            for trade in trade_data:
                if 'side' in trade and 'sz' in trade:
                    try:
                        size = float(trade['sz'])
                        sign = 1 if trade['side'] == 'buy' else -1
                        self.trade_history.append((current_time, sign * size))
                        
                        if trade['side'] == 'buy':
                            self.trade_counts['buy'] += 1
                        else:
                            self.trade_counts['sell'] += 1
                    except (ValueError, TypeError):
                        continue
            
            self.trade_history = [(ts, vol) for ts, vol in self.trade_history 
                                 if current_time - ts <= 20]
            
            self.cumulative_delta = sum(vol for ts, vol in self.trade_history)
            
            return self.cumulative_delta
            
        except Exception as e:
            return self.cumulative_delta
    
    def calculate_volatility(self):
        """–†–∞—Å—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏"""
        try:
            if len(self.price_history) < 2:
                return 0
                
            prices = [dp['price'] for dp in self.price_history[-self.volatility_window:]]
            if len(prices) < 2:
                return 0
                
            returns = []
            for i in range(1, len(prices)):
                if prices[i-1] != 0:
                    ret = (prices[i] - prices[i-1]) / prices[i-1]
                    returns.append(ret)
            
            if len(returns) < 2:
                return 0
                
            volatility = np.std(returns) * 100
            return volatility
            
        except Exception as e:
            return 0
    
    def extract_funding_rate(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç funding rate"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            ticker = ticker_data[0]
            return float(ticker.get('fundingRate', 0))
        except Exception as e:
            return 0
    
    def get_current_price(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            
            ticker = ticker_data[0]
            
            price_fields = ['last', 'lastPrice', 'close', 'markPx']
            for field in price_fields:
                if field in ticker and ticker[field]:
                    price = float(ticker[field])
                    if 1000 < price < 200000:
                        return price
            
            if 'askPx' in ticker and 'bidPx' in ticker:
                if ticker['askPx'] and ticker['bidPx']:
                    bid = float(ticker['bidPx'])
                    ask = float(ticker['askPx'])
                    if bid > 0 and ask > 0 and bid < ask:
                        price = (bid + ask) / 2
                        if 1000 < price < 200000:
                            return price
            
            return 0
            
        except Exception as e:
            return 0
    
    def calculate_target(self, current_price, future_price):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç target —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø–æ—Ä–æ–≥–æ–º"""
        if current_price == 0 or future_price == 0:
            return 0
            
        price_change = (future_price - current_price) / current_price * 100
        
        if price_change > self.target_threshold:    # 0.01%
            return 1
        elif price_change < -self.target_threshold: # -0.01%
            return -1
        else:
            return 0
    
    def should_update_features(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ñ–∏—á–∏"""
        current_time = time.time()
        if current_time - self.last_update_time >= self.update_interval:
            self.last_update_time = current_time
            return True
        return False
    
    def update_price_history(self, current_price, features):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –ë–ï–ó –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π"""
        if current_price == 0:
            return None
            
        current_time = datetime.now()
        
        # üîß –£–ë–†–ê–ù–û –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã
        # if len(self.price_history) > 0:
        #     last_time = self.price_history[-1]['timestamp']
        #     time_diff = (current_time - last_time).total_seconds()
        #     if time_diff < 0.5:
        #         return None
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        self.price_history.append({
            'timestamp': current_time,
            'price': current_price,
            'features': features.copy(),
            'target_calculated': False
        })
        
        if len(self.price_history) > 200:
            self.price_history = self.price_history[-200:]
        
        # –î–µ–±–∞–≥ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
        current_timestamp = time.time()
        if current_timestamp - self.last_history_debug > 10:
            self.last_history_debug = current_timestamp
            oldest_age = 0
            if self.price_history:
                oldest_age = (current_time - self.price_history[0]['timestamp']).total_seconds()
            
            target_time = current_time - timedelta(seconds=self.target_horizon)
            eligible_count = sum(1 for dp in self.price_history if dp['timestamp'] <= target_time)
            calculated_count = sum(1 for dp in self.price_history if dp.get('target_calculated', False))
            
            print(f"üìà History: {len(self.price_history)} records, oldest: {oldest_age:.1f}s")
            print(f"üîç Target: {eligible_count} eligible, {calculated_count} calculated")
        
        # –†–ê–°–ß–ï–¢ TARGET
        target_time = current_time - timedelta(seconds=self.target_horizon)
        targets_calculated = 0
        
        for data_point in self.price_history:
            if (data_point['timestamp'] <= target_time and 
                not data_point['target_calculated']):
                
                future_price = current_price
                current_price_at_time = data_point['price']
                
                target = self.calculate_target(current_price_at_time, future_price)
                data_point['features']['target'] = target
                data_point['target_calculated'] = True
                targets_calculated += 1
                
                # –õ–æ–≥–∏—Ä—É–µ–º –í–°–ï —Ä–∞—Å—á–µ—Ç—ã target
                price_change = (future_price - current_price_at_time) / current_price_at_time * 100
                if target != 0:  # üîß –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–Ω—É–ª–µ–≤—ã–µ target
                    print(f"üéØ TARGET: {target} (change: {price_change:.3f}%)")
        
        if targets_calculated > 0:
            print(f"‚úÖ Calculated {targets_calculated} targets")
            
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏—á–∏ —Å target
            for data_point in reversed(self.price_history):
                if 'target' in data_point['features'] and data_point['features']['target'] != 0:
                    return data_point['features']
        
        return None
    
    def get_all_features(self, order_book_data, trade_data, ticker_data):
        """–°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Ñ–∏—á–∏"""
        if not self.should_update_features():
            if self.price_history:
                return self.price_history[-1]['features']
            else:
                return self.create_empty_features()
        
        self.update_cumulative_delta(trade_data)
        
        current_price = self.get_current_price(ticker_data)
        
        if current_price == 0:
            if self.price_history:
                return self.price_history[-1]['features']
            else:
                return self.create_empty_features()
        
        volatility = self.calculate_volatility()
        
        features = {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': self.calculate_order_book_imbalance(order_book_data),
            'spread_percent': self.calculate_spread(order_book_data),
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': self.extract_funding_rate(ticker_data),
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': current_price,
            'volatility': volatility,
            'target': 0
        }
        
        updated_features = self.update_price_history(current_price, features)
        
        if updated_features is not None:
            return updated_features
        else:
            return features

    def create_empty_features(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø—É—Å—Ç—ã–µ —Ñ–∏—á–∏"""
        return {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': 0.5,
            'spread_percent': 0.1,
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': 0,
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': 0,
            'volatility': 0,
            'target': 0
        }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
feature_engine = FeatureEngine()


===== live_predictor.py =====


# live_predictor.py
import joblib
import pandas as pd
from datetime import datetime
import time
from data_collector import data_collector
from feature_engine import feature_engine

class LivePredictor:
    def __init__(self):
        self.model = joblib.load("models/quant_model.pkl")
        self.feature_columns = [
            'order_book_imbalance', 'spread_percent', 'cumulative_delta',
            'funding_rate', 'buy_trades', 'sell_trades', 'total_trades'
        ]
        self.prediction_count = 0
        
    def make_prediction(self, features):
        """–î–µ–ª–∞–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∏—á"""
        try:
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–¥–µ–ª–∏
            X = pd.DataFrame([[
                features['order_book_imbalance'],
                features['spread_percent'],
                features['cumulative_delta'],
                features['funding_rate'],
                features['buy_trades'],
                features['sell_trades'],
                features['total_trades']
            ]], columns=self.feature_columns)
            
            # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
            prediction = self.model.predict(X)[0]
            probability = self.model.predict_proba(X)[0]
            
            self.prediction_count += 1
            
            return {
                'prediction': prediction,
                'probability': max(probability),
                'confidence': f"{max(probability)*100:.1f}%",
                'timestamp': datetime.now().strftime("%H:%M:%S")
            }
            
        except Exception as e:
            print(f"‚ùå Prediction error: {e}")
            return None
    
    def start_live_predictions(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
        print("üéØ LIVE ML PREDICTIONS STARTED...")
        print("=" * 50)
        
        last_print_time = 0
        
        while True:
            current_time = time.time()
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ —Ñ–∏—á–∏
            features = feature_engine.get_all_features(
                data_collector.order_book_data,
                data_collector.trade_data, 
                data_collector.ticker_data
            )
            
            # –î–µ–ª–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
            if current_time - last_print_time >= 10:
                last_print_time = current_time
                
                prediction = self.make_prediction(features)
                
                if prediction:
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –∏ —Å–∏–º–≤–æ–ª –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    if prediction['prediction'] == 1:
                        symbol = "üü¢ LONG"
                        color = "\033[92m"  # –ó–µ–ª–µ–Ω—ã–π
                    elif prediction['prediction'] == -1:
                        symbol = "üî¥ SHORT" 
                        color = "\033[91m"  # –ö—Ä–∞—Å–Ω—ã–π
                    else:
                        symbol = "‚ö™ HOLD"
                        color = "\033[90m"  # –°–µ—Ä—ã–π
                    
                    # –í—ã–≤–æ–¥ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    print(f"{color}üéØ [{prediction['timestamp']}] {symbol} | Confidence: {prediction['confidence']} | "
                          f"Imbalance: {features['order_book_imbalance']:.3f} | Delta: {features['cumulative_delta']:.1f}\033[0m")
                    
                    # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –±–µ–π–∑–ª–∞–π–Ω–æ–º
                    from baseline_strategy import baseline_strategy
                    baseline = baseline_strategy.analyze_signal(features)
                    print(f"   ü§ñ Baseline: {baseline['decision']} ({baseline['confidence']:.0f}%) vs ML: {symbol} ({prediction['confidence']})")
                    print("-" * 50)
            
            time.sleep(1)

if __name__ == "__main__":
    predictor = LivePredictor()
    predictor.start_live_predictions()


===== main.py =====


# main.py
from data_collector import data_collector
from data_monitor import DataMonitor
import time

def main():
    print("üöÄ Quantum Bot Starting...")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
    data_collector.start()
    
    # –ú–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    monitor = DataMonitor()
    
    # –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
    try:
        last_progress_check = 0
        
        while True:
            current_time = time.time()
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
            if current_time - last_progress_check > 120:
                monitor.print_progress_report()
                last_progress_check = current_time
            
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nüõë Bot stopped")

if __name__ == "__main__":
    main()


===== train_model.py =====


# train_model.py
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
from sklearn.metrics import classification_report, accuracy_score
import joblib
import os

def load_training_data():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
    data_file = "data/training_data.csv"
    
    if not os.path.exists(data_file):
        print("‚ùå –§–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ.")
        return None
    
    df = pd.read_csv(data_file)
    print(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(df)} –∑–∞–ø–∏—Å–µ–π")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ target
    if 'target' not in df.columns or df['target'].isna().all():
        print("‚ùå –ù–µ—Ç —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (target). –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö.")
        return None
    
    # –£–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –±–µ–∑ target
    df = df.dropna(subset=['target'])
    df['target'] = df['target'].astype(int)
    
    print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {len(df)}")
    print(f"üìà –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target: {df['target'].value_counts().to_dict()}")
    
    return df

def create_baseline_model(df):
    """–°–æ–∑–¥–∞–µ—Ç –±–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–∞–≤–∏–ª"""
    print("\nü§ñ –ë–ï–ô–ó–õ–ê–ô–ù –ú–û–î–ï–õ–¨ (–ø—Ä–∞–≤–∏–ª–∞):")
    
    # –ü—Ä–∞–≤–∏–ª–æ 1: Imbalance > 0.6 = –ø–æ–∫—É–ø–∞—Ç—å
    df['baseline_imbalance'] = (df['order_book_imbalance'] > 0.6).astype(int)
    accuracy_imbalance = accuracy_score(df['target'] == 1, df['baseline_imbalance'])
    print(f"üìä Imbalance > 0.6 accuracy: {accuracy_imbalance:.3f}")
    
    # –ü—Ä–∞–≤–∏–ª–æ 2: Delta > 0 = –ø–æ–∫—É–ø–∞—Ç—å
    df['baseline_delta'] = (df['cumulative_delta'] > 0).astype(int)
    accuracy_delta = accuracy_score(df['target'] == 1, df['baseline_delta'])
    print(f"üìà Delta > 0 accuracy: {accuracy_delta:.3f}")
    
    # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ
    df['baseline_combined'] = ((df['order_book_imbalance'] > 0.6) & 
                              (df['cumulative_delta'] > 0)).astype(int)
    accuracy_combined = accuracy_score(df['target'] == 1, df['baseline_combined'])
    print(f"üéØ Combined rule accuracy: {accuracy_combined:.3f}")

def train_ml_model(df):
    """–û–±—É—á–∞–µ—Ç ML –º–æ–¥–µ–ª—å"""
    print("\nüß† –û–ë–£–ß–ï–ù–ò–ï ML –ú–û–î–ï–õ–ò...")
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –º–æ–¥–µ–ª–∏
    feature_columns = [
        'order_book_imbalance',
        'spread_percent', 
        'cumulative_delta',
        'funding_rate',
        'buy_trades',
        'sell_trades',
        'total_trades'
    ]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    missing_features = [f for f in feature_columns if f not in df.columns]
    if missing_features:
        print(f"‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏: {missing_features}")
        return None
    
    X = df[feature_columns]
    y = df['target']
    
    # –£–±–∏—Ä–∞–µ–º NaN
    mask = ~X.isna().any(axis=1)
    X = X[mask]
    y = y[mask]
    
    print(f"üìä –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è: {len(X)} –∑–∞–ø–∏—Å–µ–π")
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ä—è–¥–∞–º–∏
    tscv = TimeSeriesSplit(n_splits=5)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
    scores = cross_val_score(model, X, y, cv=tscv, scoring='accuracy')
    print(f"üìä –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è accuracy: {scores.mean():.3f} (+/- {scores.std() * 2:.3f})")
    
    # –û–±—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –º–æ–¥–µ–ª–∏
    model.fit(X, y)
    print("‚úÖ –ú–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–∞!")
    
    # –í–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    feature_importance = pd.DataFrame({
        'feature': feature_columns,
        'importance': model.feature_importances_
    }).sort_values('importance', ascending=False)
    
    print("\nüéØ –í–ê–ñ–ù–û–°–¢–¨ –ü–†–ò–ó–ù–ê–ö–û–í:")
    for _, row in feature_importance.iterrows():
        print(f"  {row['feature']}: {row['importance']:.3f}")
    
    return model

def save_model(model, filename="models/quant_model.pkl"):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å"""
    os.makedirs("models", exist_ok=True)
    joblib.dump(model, filename)
    print(f"üíæ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

def main():
    print("üöÄ –ó–ê–ü–£–°–ö –û–ë–£–ß–ï–ù–ò–Ø –ú–û–î–ï–õ–ò...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    df = load_training_data()
    if df is None or len(df) < 50:
        print(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è. –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 50 –∑–∞–ø–∏—Å–µ–π, —Å–µ–π—á–∞—Å: {len(df) if df is not None else 0}")
        return
    
    # –ë–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å
    create_baseline_model(df)
    
    # ML –º–æ–¥–µ–ª—å (–µ—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö)
    if len(df) >= 50:
        model = train_ml_model(df)
        if model:
            save_model(model)
            print("\nüéâ –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.")
    else:
        print(f"üìä –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö. –°–µ–π—á–∞—Å: {len(df)}/50")

if __name__ == "__main__":
    main()
