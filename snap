

===== config.py =====


SYMBOL = "BTC-USDT-SWAP"
BUCKET_SECONDS = 60.0

# –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
IMBALANCE_THRESHOLD = 0.7

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–Ω—Ç–∏-—Å–ø—É—Ñ–∏–Ω–≥–∞
MIN_VOLUME_ANTI_SPOOFING = 0.5  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä–µ–º –¥–ª—è –¥–æ–≤–µ—Ä–∏—è –∏–º–±–∞–ª–∞–Ω—Å—É

===== data_collector.py =====


# data_collector.py
import json
import threading
import websocket
import time
from datetime import datetime
from config import SYMBOL

class LiveDataCollector:
    def __init__(self):
        self.price = None
        self.best_bid = None
        self.best_ask = None
        self.spread = None
        self.bids = []
        self.asks = []
        self.trades = []
        
        self.lock = threading.Lock()
        self._ws = None
        self.connected = False

        print("[Collector] Starting OKX WebSocket connection...")
        self._start_ws()

    def _start_ws(self):
        url = "wss://ws.okx.com:8443/ws/v5/public"
        self._ws = websocket.WebSocketApp(
            url,
            on_open=self._on_open,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close
        )

        self.ws_thread = threading.Thread(target=self._ws.run_forever, daemon=True)
        self.ws_thread.start()

    def _on_open(self, ws):
        print("[Collector] ‚úÖ Connected to OKX WebSocket")
        self.connected = True
        
        sub_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "books5", "instId": SYMBOL},
                {"channel": "trades", "instId": SYMBOL}
            ]
        }
        ws.send(json.dumps(sub_msg))
        print("[Collector] ‚úÖ Subscribed to books5 & trades")

    def _on_error(self, ws, error):
        print(f"[Collector] ‚ùå WebSocket error: {error}")
        self.connected = False

    def _on_close(self, ws, close_status_code, close_msg):
        print(f"[Collector] üîå WebSocket closed: {close_status_code} - {close_msg}")
        self.connected = False

    def _on_message(self, ws, message):
        try:
            msg = json.loads(message)
            
            if "event" in msg:
                if msg["event"] == "subscribe":
                    print(f"[Collector] ‚úÖ Subscribed to: {msg.get('arg', {})}")
                return

            if "arg" not in msg:
                return

            channel = msg["arg"]["channel"]

            with self.lock:
                if channel == "books5" and "data" in msg:
                    self._handle_books(msg["data"][0])
                elif channel == "trades" and "data" in msg:
                    self._handle_trades(msg["data"])
                    
        except Exception as e:
            print(f"[Collector] ‚ùå Message processing error: {e}")

    def _handle_books(self, book_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞–∫–∞–Ω"""
        try:
            self.bids = book_data.get("bids", [])
            self.asks = book_data.get("asks", [])
            
            if self.bids and self.asks:
                self.best_bid = float(self.bids[0][0])
                self.best_ask = float(self.asks[0][0])
                self.price = (self.best_bid + self.best_ask) / 2
                self.spread = self.best_ask - self.best_bid
                
        except Exception as e:
            print(f"[Collector] ‚ùå Book processing error: {e}")

    def _handle_trades(self, trades_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–π–¥—ã"""
        try:
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –±–µ—Ä–µ–º –í–°–ï —Ç—Ä–µ–π–¥—ã
            if trades_data:
                self.trades = trades_data
        except Exception as e:
            print(f"[Collector] ‚ùå Trade processing error: {e}")

    def get_snapshot(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Å–Ω–∞–ø—à–æ—Ç –¥–∞–Ω–Ω—ã—Ö"""
        with self.lock:
            return {
                "order_book": {
                    "bids": self.bids,
                    "asks": self.asks,
                    "ts": datetime.utcnow().isoformat()
                },
                "trades": self.trades,
                "price": self.price,
                "spread": self.spread,
                "connected": self.connected
            }

    def stop(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if self._ws:
            self._ws.close()
        self.connected = False

===== feature_engine.py =====


from collections import deque
import time
from datetime import datetime

class FeatureEngine:
    def __init__(self):
        self.last_price = 60000.0
        self.imbalance_history = deque(maxlen=2)  # –î–ª—è —Ç—Ä–µ–Ω–¥–∞
        self.trade_history = deque()  # (timestamp, side, volume)
        self.price_history = deque()  # (timestamp, price)

    def _calculate_imbalance(self, bids, asks, levels=3):
        """–†–∞—Å—á–µ—Ç –∏–º–±–∞–ª–∞–Ω—Å–∞"""
        levels = min(len(bids), len(asks), levels)
        if levels == 0:
            return 0.5
            
        bid_vol = sum(float(bid[1]) for bid in bids[:levels])
        ask_vol = sum(float(ask[1]) for bid in asks[:levels])
        total = bid_vol + ask_vol
        
        return bid_vol / total if total > 0 else 0.5

    def update_trades(self, trades):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–µ–π–¥–æ–≤"""
        ts = time.time()
        for trade in trades:
            side = trade.get("side", "buy")  # "buy" –∏–ª–∏ "sell"
            volume = float(trade.get("sz", 0))
            self.trade_history.append((ts, side, volume))
        # –î–æ–±–∞–≤–ª—è–µ–º —Ü–µ–Ω—É –≤ –∏—Å—Ç–æ—Ä–∏—é
        self.price_history.append((ts, self.last_price))

    def compute_delta_absorption(self, window=30):
        """–°—á–∏—Ç–∞–µ–º –¥–µ–ª—å—Ç—É –∏ absorption –∑–∞ –æ–∫–Ω–æ"""
        now = time.time()
        # —á–∏—Å—Ç–∏–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
        while self.trade_history and self.trade_history[0][0] < now - window:
            self.trade_history.popleft()
        while self.price_history and self.price_history[0][0] < now - window:
            self.price_history.popleft()

        # –¥–µ–ª—å—Ç–∞
        delta = sum(v for t,s,v in self.trade_history if s=="buy") - sum(v for t,s,v in self.trade_history if s=="sell")
        # –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã
        price_change = self.last_price - self.price_history[0][1] if self.price_history else 0

        absorption_up = price_change > 0 and delta <= 0
        absorption_down = price_change < 0 and delta >= 0

        return {
            "delta": delta,
            "price_change": price_change,
            "absorption_up": absorption_up,
            "absorption_down": absorption_down
        }

    def update_from_snapshot(self, snapshot):
        current_time = time.time()
        ob = snapshot.get("order_book", {})
        trades = snapshot.get("trades", [])

        # –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã
        bids = ob.get("bids", [])
        asks = ob.get("asks", [])
        if bids and asks:
            try:
                best_bid = float(bids[0][0])
                best_ask = float(asks[0][0])
                if best_ask > best_bid:
                    self.last_price = (best_bid + best_ask) / 2
            except (ValueError, IndexError):
                pass

        # —Ä–∞—Å—á–µ—Ç –∏–º–±–∞–ª–∞–Ω—Å–∞
        current_imbalance = 0.5
        if bids and asks:
            current_imbalance = self._calculate_imbalance(bids, asks)
            self.imbalance_history.append(current_imbalance)

        # —Ç—Ä–µ–Ω–¥ –∏–º–±–∞–ª–∞–Ω—Å–∞
        if len(self.imbalance_history) >= 2:
            trend = "rising" if current_imbalance > self.imbalance_history[-2] else "falling"
        else:
            trend = "flat"

        # –æ–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é —Ç—Ä–µ–π–¥–æ–≤
        self.update_trades(trades)
        abs_features = self.compute_delta_absorption(window=30)

        return {
            "timestamp": datetime.utcnow().isoformat(),
            "order_book_imbalance": round(current_imbalance, 4),
            "imbalance_trend": trend,
            "current_price": round(self.last_price, 2),
            **abs_features
        }

feature_engine = FeatureEngine()


===== main.py =====


import time
from data_collector import LiveDataCollector
from feature_engine import feature_engine
from simple_strategy import SimpleStrategy
from telegram_notifier import telegram
from config import BUCKET_SECONDS

def run_bot():
    print("Bot starting...")
    telegram.send_bot_status("start")

    collector = LiveDataCollector()
    strat = SimpleStrategy()

    time.sleep(5)
    print("Bot is running...")

    try:
        while True:
            snapshot = collector.get_snapshot()
            if not snapshot.get("connected", False):
                print("WebSocket not connected")
                time.sleep(1)
                continue

            features = feature_engine.update_from_snapshot(snapshot)
            
            print(f"Price: {features['current_price']}")
            print(f"Imbalance: {features['order_book_imbalance']:.3f}")
            print(f"Trend: {features['imbalance_trend']}")
            print(f"Delta: {features['delta']}")
            print(f"Absorption UP: {features['absorption_up']}, Absorption DOWN: {features['absorption_down']}")
            print("---")

            result = strat.analyze(features)

            if result["action"] == "ENTER":
                side = result["side"]
                price = result["price"]
                strat.record_entry(side, price)
                telegram.send_trade_signal(side, price)
                print(f"SIGNAL: {side} {price:.2f}")
                print("===")
            else:
                print(f"HOLD: {result['reason']}")
                print("---")

            time.sleep(BUCKET_SECONDS)

    except KeyboardInterrupt:
        print("Bot stopped")
        telegram.send_bot_status("stop")

if __name__ == "__main__":
    run_bot()


===== simple_strategy.py =====


import time
from config import IMBALANCE_THRESHOLD

class SimpleStrategy:
    def __init__(self):
        self.open_position = None

    def analyze(self, features):
        imb = features.get("order_book_imbalance", 0.5)
        trend = features.get("imbalance_trend", "flat")
        price = features.get("current_price", 0.0)
        delta = features.get("delta", 0)
        abs_up = features.get("absorption_up", False)
        abs_down = features.get("absorption_down", False)

        if self.open_position is not None:
            return {"action": "HOLD", "reason": "position_open"}

        # LONG —Å–∏–≥–Ω–∞–ª
        if imb > IMBALANCE_THRESHOLD and trend == "rising" and not abs_up and delta > 5:
            return {
                "action": "ENTER", 
                "side": "LONG", 
                "price": price,
                "reason": "strong_buy_pressure"
            }

        # SHORT —Å–∏–≥–Ω–∞–ª  
        if imb < (1 - IMBALANCE_THRESHOLD) and trend == "falling" and not abs_down and delta < -5:
            return {
                "action": "ENTER",
                "side": "SHORT", 
                "price": price,
                "reason": "strong_sell_pressure"
            }

        return {"action": "HOLD", "reason": f"no_signal imb:{imb:.3f} trend:{trend}"}

    def record_entry(self, side, price):
        self.open_position = {
            "side": side,
            "entry_price": price,
            "entry_ts": time.time()
        }


===== telegram_notifier.py =====


# telegram_notifier.py
import requests
import os

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")

class TelegramNotifier:
    def __init__(self):
        self.enabled = bool(TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID)
        print(f"[Telegram] Enabled: {self.enabled}")

    def _send_message(self, message):
        if not self.enabled:
            return
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            payload = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
            requests.post(url, json=payload, timeout=5)
        except:
            pass

    def send_bot_status(self, status):
        self._send_message(status)

    def send_trade_signal(self, side, price):
        self._send_message(f"{side.lower()} {price:.2f}")

telegram = TelegramNotifier()