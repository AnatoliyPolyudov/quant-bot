

===== baseline_strategy.py =====


# baseline_strategy.py
class BaselineStrategy:
    def __init__(self):
        self.min_imbalance = 0.6
        self.min_delta = 10
        self.max_spread = 0.02  # –£–í–ï–õ–ò–ß–ï–ù–û –¥–æ 0.02% (–±—ã–ª–æ 0.05%)
        
    def analyze_signal(self, features):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ñ–∏—á–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª"""
        imbalance = features.get('order_book_imbalance', 0.5)
        delta = features.get('cumulative_delta', 0)
        spread = features.get('spread_percent', 0)
        funding = features.get('funding_rate', 0)
        
        # –ë–∞–∑–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞
        signals = []
        
        # –ü—Ä–∞–≤–∏–ª–æ 1: –°–∏–ª—å–Ω—ã–π imbalance –≤ –ø–æ–ª—å–∑—É –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π
        if imbalance > self.min_imbalance:
            signals.append(f"üìä Imbalance {imbalance:.3f} > {self.min_imbalance}")
        
        # –ü—Ä–∞–≤–∏–ª–æ 2: –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π cumulative delta
        if delta > self.min_delta:
            signals.append(f"üìà Delta {delta:.1f} > {self.min_delta}")
        
        # –ü—Ä–∞–≤–∏–ª–æ 3: –ù–∏–∑–∫–∏–π —Å–ø—Ä–µ–¥
        if spread < self.max_spread:
            signals.append(f"üìè Spread {spread:.4f}% < {self.max_spread}%")
        else:
            signals.append(f"‚ùå Spread {spread:.4f}% —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫")
        
        # –ü—Ä–∞–≤–∏–ª–æ 4: –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ
        if abs(funding) < 0.0001:
            signals.append("üí∞ Funding –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π")
        else:
            signals.append(f"‚ö†Ô∏è Funding {funding:.6f}")
        
        # –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è
        buy_signal = (imbalance > self.min_imbalance and 
                     delta > self.min_delta and 
                     spread < self.max_spread)
        
        sell_signal = (imbalance < (1 - self.min_imbalance) and 
                      delta < -self.min_delta and 
                      spread < self.max_spread)
        
        if buy_signal:
            decision = "LONG"
            confidence = min(imbalance * 100, 95)
        elif sell_signal:
            decision = "SHORT" 
            confidence = min((1 - imbalance) * 100, 95)
        else:
            decision = "HOLD"
            confidence = 0
        
        return {
            'decision': decision,
            'confidence': confidence,
            'signals': signals,
            'imbalance': imbalance,
            'delta': delta,
            'spread': spread
        }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
baseline_strategy = BaselineStrategy()


===== config.py =====


# config.py

# Trading settings
SYMBOL = "BTC-USDT-SWAP"
TIMEFRAME = "1m"

# Data collection
WS_URL = "wss://ws.okx.com:8443/ws/v5/public"
CHANNELS = [
    "books",              # –°—Ç–∞–∫–∞–Ω L2
    "trades",             # –õ–µ–Ω—Ç–∞ —Å–¥–µ–ª–æ–∫
    "tickers"             # –¢–∏–∫–µ—Ä—ã (funding, OI)
]

# Feature settings
FEATURE_WINDOW = 50

# Model settings
MIN_PROBABILITY = 0.65


===== data_collector.py =====


# data_collector.py
import websocket
import json
import threading
import time
from datetime import datetime
from feature_engine import feature_engine
from data_logger import data_logger
from baseline_strategy import baseline_strategy

class OKXDataCollector:
    def __init__(self):
        self.ws = None
        self.data_buffer = []
        self.message_count = 0
        self.last_feature_print = 0
        self.last_data_log = 0
        
        # –†–∞–∑–¥–µ–ª—å–Ω—ã–µ –±—É—Ñ–µ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
        self.order_book_data = []
        self.trade_data = []
        self.ticker_data = []
        
    def on_message(self, ws, message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            data = json.loads(message)
            self.message_count += 1
            
            # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–µ—Ä–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            if self.message_count <= 3:
                print(f"\nüîç RAW MESSAGE #{self.message_count}:")
                print(f"   Keys: {list(data.keys())}")
                if 'arg' in data:
                    print(f"   Channel: {data['arg']}")
                if 'data' in data:
                    print(f"   Data length: {len(data['data'])}")
                    if len(data['data']) > 0:
                        print(f"   First item keys: {list(data['data'][0].keys())}")
                        print(f"   Sample: {str(data['data'][0])[:200]}...")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
            if 'event' in data:
                if data['event'] != 'subscribe':  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏
                    print(f"‚ö° Event: {data['event']} - {data.get('msg', '')}")
            elif 'data' in data:
                channel = data.get('arg', {}).get('channel', 'unknown')
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –±—É—Ñ–µ—Ä—ã
                if channel == 'books':
                    self.order_book_data = data['data']
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å—Ç–∞–∫–∞–Ω–∞
                    if self.message_count <= 3 and len(data['data']) > 0:
                        book = data['data'][0]
                        print(f"   üìö Order Book - Bids: {len(book.get('bids', []))}, Asks: {len(book.get('asks', []))}")
                        
                elif channel == 'trades':
                    self.trade_data = data['data']
                    if self.message_count <= 3 and len(data['data']) > 0:
                        trade = data['data'][0]
                        print(f"   üí∞ Trade - Side: {trade.get('side')}, Size: {trade.get('sz')}")
                        
                elif channel == 'tickers':
                    self.ticker_data = data['data']
                    if self.message_count <= 3 and len(data['data']) > 0:
                        ticker = data['data'][0]
                        print(f"   üìà Ticker - Last: {ticker.get('last')}, Funding: {ticker.get('fundingRate')}")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏—á–∏ –∏ –≤—ã–≤–æ–¥–∏–º/–ª–æ–≥–∏—Ä—É–µ–º
                self.update_features()
                
        except Exception as e:
            print(f"‚ùå Message error: {e}")
    
    def update_features(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ñ–∏—á–∏ –∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤—ã–≤–æ–¥–æ–º/–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        current_time = time.time()
        
        # –í—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏—á–∏
        features = feature_engine.get_all_features(
            self.order_book_data, 
            self.trade_data, 
            self.ticker_data
        )
        
        # –ê–Ω–∞–ª–∏–∑ –±–µ–π–∑–ª–∞–π–Ω-—Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
        strategy_result = baseline_strategy.analyze_signal(features)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ (–ª–æ–≥–∏–∫–∞ —Ç–µ–ø–µ—Ä—å –≤ data_logger)
        data_logger.log_features(features)
        
        # –í—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥ (—á–∞—â–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
        if current_time - self.last_feature_print > 10:
            self.last_feature_print = current_time
            
            print("\n" + "="*50)
            print(f"üéØ REAL-TIME FEATURES (Msg #{self.message_count})")
            print("="*50)
            
            print(f"üìä Order Book Imbalance: {features['order_book_imbalance']:.3f}")
            print(f"üìè Spread: {features['spread_percent']:.6f}%")
            print(f"üìà Cumulative Delta: {features['cumulative_delta']:.4f}")
            print(f"üí∞ Funding Rate: {features['funding_rate']:.8f}")
            print(f"üîÑ Trades: {features['buy_trades']} buy / {features['sell_trades']} sell")
            print(f"üíµ Current Price: {features['current_price']}")
            
            print(f"\nü§ñ BASELINE DECISION: {strategy_result['decision']}")
            print(f"üéØ Confidence: {strategy_result['confidence']:.1f}%")
            
            for signal in strategy_result['signals']:
                print(f"   {signal}")
                
            print(f"üìä Data buffers - OB: {len(self.order_book_data)}, Trades: {len(self.trade_data)}, Ticker: {len(self.ticker_data)}")
            print("="*50 + "\n")
    
    def on_error(self, ws, error):
        print(f"‚ùå WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("üîå WebSocket closed")
        # –ê–≤—Ç–æ–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        time.sleep(5)
        self.start()
    
    def on_open(self, ws):
        print(f"üîå WebSocket connected at {datetime.now()}")
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–∞–Ω–∞–ª—ã
        from config import CHANNELS, SYMBOL
        for channel in CHANNELS:
            subscribe_msg = {
                "op": "subscribe",
                "args": [
                    {
                        "channel": channel,
                        "instId": SYMBOL
                    }
                ]
            }
            ws.send(json.dumps(subscribe_msg))
            print(f"üì° Subscribed to: {channel} for {SYMBOL}")
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
        from config import WS_URL
        
        self.ws = websocket.WebSocketApp(
            WS_URL,
            on_message=self.on_message,
            on_error=self.on_error, 
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        self.ws_thread = threading.Thread(target=self.ws.run_forever)
        self.ws_thread.daemon = True
        self.ws_thread.start()
        print("üöÄ Data collector started")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –í –ö–û–ù–¶–ï –§–ê–ô–õ–ê
data_collector = OKXDataCollector()


===== data_logger.py =====


# data_logger.py
import csv
import os
from datetime import datetime

class DataLogger:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        self.setup_data_file()
        self.last_log_time = 0
        self.log_interval = 30  # –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
    
    def setup_data_file(self):
        """–°–æ–∑–¥–∞–µ—Ç —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –≤–∫–ª—é—á–∞—è target"""
        os.makedirs("data", exist_ok=True)
        
        if not os.path.exists(self.data_file):
            with open(self.data_file, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow([
                    'timestamp',
                    'order_book_imbalance',
                    'spread_percent', 
                    'cumulative_delta',
                    'funding_rate',
                    'buy_trades',
                    'sell_trades',
                    'total_trades',
                    'current_price',
                    'target'
                ])
            print("üìÅ Created new training_data.csv")
    
    def log_features(self, features):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–∏—á–∏ –≤ CSV –ö–ê–ñ–î–´–ï 30 –°–ï–ö–£–ù–î"""
        try:
            current_time = time.time()
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥ –ò –µ—Å–ª–∏ –µ—Å—Ç—å target
            if (current_time - self.last_log_time >= self.log_interval and 
                features.get('target', 0) != 0):
                
                self.last_log_time = current_time
                
                with open(self.data_file, 'a', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow([
                        features['timestamp'],
                        features['order_book_imbalance'],
                        features['spread_percent'],
                        features['cumulative_delta'],
                        features['funding_rate'],
                        features['buy_trades'],
                        features['sell_trades'],
                        features['total_trades'],
                        features['current_price'],
                        features['target']
                    ])
                print(f"üíæ Data logged: target={features['target']}")
                
        except Exception as e:
            print(f"‚ùå Data logging error: {e}")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
data_logger = DataLogger()


===== data_monitor.py =====


# data_monitor.py
import os
import csv
from datetime import datetime
import time

class DataMonitor:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        
    def check_data_progress(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ pandas"""
        if not os.path.exists(self.data_file):
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'NO_DATA'
            }
        
        try:
            total_records = 0
            labeled_records = 0
            target_dist = {-1: 0, 0: 0, 1: 0}
            
            with open(self.data_file, 'r') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    total_records += 1
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º target
                    if 'target' in row and row['target'].strip():
                        try:
                            target_val = int(row['target'])
                            labeled_records += 1
                            if target_val in [-1, 0, 1]:
                                target_dist[target_val] += 1
                        except ValueError:
                            pass
            
            # –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
            if labeled_records == 0 and total_records > 0:
                quality = 'COLLECTING'
            elif labeled_records < 50:
                quality = 'MINIMAL'
            elif labeled_records < 200:
                quality = 'GOOD'
            else:
                quality = 'EXCELLENT'
                
            # –£–±–∏—Ä–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            target_dist = {k: v for k, v in target_dist.items() if v > 0}
            
            return {
                'total_records': total_records,
                'labeled_records': labeled_records,
                'target_distribution': target_dist,
                'data_quality': quality
            }
            
        except Exception as e:
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'ERROR'
            }
    
    def print_progress_report(self):
        """–í—ã–≤–æ–¥–∏—Ç –æ—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ"""
        progress = self.check_data_progress()
        
        print("\n" + "="*60)
        print("üìä –û–¢–ß–ï–¢ –û –°–ë–û–†–ï –î–ê–ù–ù–´–•")
        print("="*60)
        
        print(f"üìÅ –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {progress['total_records']}")
        print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {progress['labeled_records']}")
        print(f"üìà –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality']}")
        
        if progress['target_distribution']:
            print(f"üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target: {progress['target_distribution']}")
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if progress['data_quality'] == 'NO_DATA':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö")
        elif progress['data_quality'] == 'COLLECTING':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –î–∞–Ω–Ω—ã–µ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è, target —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç")
        elif progress['data_quality'] == 'MINIMAL':
            records_needed = 50 - progress['labeled_records']
            print(f"üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –°–æ–±–µ—Ä–∏—Ç–µ –µ—â–µ {records_needed} –∑–∞–ø–∏—Å–µ–π –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
        elif progress['data_quality'] == 'GOOD':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏!")
        elif progress['data_quality'] == 'EXCELLENT':
            print("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –û—Ç–ª–∏—á–Ω—ã–π –æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è!")
        
        print("="*60)

def monitor_continuous():
    """–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
    monitor = DataMonitor()
    
    print("üöÄ –ó–ê–ü–£–°–ö –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –î–ê–ù–ù–´–•...")
    print("üí° –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥")
    print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
    
    try:
        while True:
            monitor.print_progress_report()
            time.sleep(30)
    except KeyboardInterrupt:
        print("\nüõë –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

if __name__ == "__main__":
    monitor_continuous()


===== feature_engine.py =====


# feature_engine.py
from datetime import datetime, timedelta
import time

class FeatureEngine:
    def __init__(self):
        self.cumulative_delta = 0
        self.trade_counts = {'buy': 0, 'sell': 0}
        self.price_history = []
        self.feature_history = []
        self.price_debug_count = 0
        self.target_calculated_count = 0
        self.last_update_time = 0
        self.update_interval = 1  # –û–±–Ω–æ–≤–ª—è—Ç—å —Ñ–∏—á–∏ —Ç–æ–ª—å–∫–æ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
        self.last_history_debug = 0
        
    def calculate_order_book_imbalance(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç imbalance –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0.5
            book = order_book_data[0]
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö OKX
            if 'bids' not in book or 'asks' not in book:
                return 0.5
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0.5
                
            bids = book['bids']
            asks = book['asks']
            
            # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 3 —É—Ä–æ–≤–Ω—è
            bid_levels = min(len(bids), 3)
            ask_levels = min(len(asks), 3)
            
            bid_volume = sum(float(bid[1]) for bid in bids[:bid_levels])
            ask_volume = sum(float(ask[1]) for ask in asks[:ask_levels])
            
            total_volume = bid_volume + ask_volume
            if total_volume == 0:
                return 0.5
                
            imbalance = bid_volume / total_volume
            return imbalance
            
        except Exception as e:
            print(f"‚ùå Order book error: {e}")
            return 0.5
    
    def calculate_spread(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–ø—Ä–µ–¥ –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0
            book = order_book_data[0]
            
            if 'bids' not in book or 'asks' not in book:
                return 0
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0
                
            best_bid = float(book['bids'][0][0])
            best_ask = float(book['asks'][0][0])
            
            spread = best_ask - best_bid
            spread_percent = (spread / best_bid) * 100
            
            return spread_percent
            
        except Exception as e:
            print(f"‚ùå Spread calculation error: {e}")
            return 0
    
    def update_cumulative_delta(self, trade_data):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç cumulative delta –∏–∑ –ª–µ–Ω—Ç—ã —Å–¥–µ–ª–æ–∫"""
        try:
            if not trade_data:
                return self.cumulative_delta
                
            for trade in trade_data:
                if 'side' in trade and 'sz' in trade:
                    size = float(trade['sz'])
                    if trade['side'] == 'buy':
                        self.cumulative_delta += size
                        self.trade_counts['buy'] += 1
                    elif trade['side'] == 'sell':
                        self.cumulative_delta -= size
                        self.trade_counts['sell'] += 1
                    
            return self.cumulative_delta
            
        except Exception as e:
            print(f"‚ùå Cumulative delta error: {e}")
            return self.cumulative_delta
    
    def extract_funding_rate(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç funding rate –∏–∑ —Ç–∏–∫–µ—Ä–æ–≤"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            ticker = ticker_data[0]
            funding_rate = float(ticker.get('fundingRate', 0))
            return funding_rate
        except Exception as e:
            print(f"‚ùå Funding rate error: {e}")
            return 0
    
    def get_current_price(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∏–∑ —Ç–∏–∫–µ—Ä–æ–≤"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            
            ticker = ticker_data[0]
            
            # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø–æ–ª—è –≥–¥–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ü–µ–Ω–∞
            price_fields = ['last', 'lastPrice', 'close', 'markPx']
            for field in price_fields:
                if field in ticker and ticker[field]:
                    return float(ticker[field])
            
            # –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä—è–º–æ–π —Ü–µ–Ω—ã, –ø—Ä–æ–±—É–µ–º mid price
            if 'askPx' in ticker and 'bidPx' in ticker:
                if ticker['askPx'] and ticker['bidPx']:
                    return (float(ticker['askPx']) + float(ticker['bidPx'])) / 2
            
            return 0
            
        except Exception as e:
            print(f"‚ùå Price extraction error: {e}")
            return 0
    
    def calculate_target(self, current_price, future_price, threshold=0.01):  # –£–ú–ï–ù–¨–®–ï–ù–û –¥–æ 0.01%
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ç—Ä–µ—Ö–∫–ª–∞—Å—Å–æ–≤—É—é —Ü–µ–ª—å (-1/0/+1)"""
        if current_price == 0 or future_price == 0:
            return 0
            
        price_change = (future_price - current_price) / current_price * 100
        
        if price_change > threshold:
            return 1
        elif price_change < -threshold:
            return -1
        else:
            return 0
    
    def should_update_features(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ñ–∏—á–∏ (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã)"""
        current_time = time.time()
        if current_time - self.last_update_time >= self.update_interval:
            self.last_update_time = current_time
            return True
        return False
    
    def update_price_history(self, current_price, features):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —Ü–µ–Ω –∏ —Ñ–∏—á–µ–π (—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã)"""
        if current_price == 0:
            return None
            
        current_time = datetime.now()
        
        # –î–ï–ë–ê–ì –ò–°–¢–û–†–ò–ò: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
        current_timestamp = time.time()
        if current_timestamp - self.last_history_debug > 5:
            self.last_history_debug = current_timestamp
            oldest_age = 0
            if self.price_history:
                oldest_age = (current_time - self.price_history[0]['timestamp']).total_seconds()
            
            # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê TARGET: –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—á–µ–º—É –Ω–µ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è
            twenty_sec_ago = current_time - timedelta(seconds=20)
            eligible_for_target = 0
            already_has_target = 0
            for data_point in self.price_history:
                if data_point['timestamp'] <= twenty_sec_ago:
                    eligible_for_target += 1
                    if 'target' in data_point['features']:
                        already_has_target += 1
            
            print(f"üìà History: {len(self.price_history)} records, oldest: {oldest_age:.1f}s")
            print(f"üîç Target diagnosis: {eligible_for_target} eligible, {already_has_target} already have target")
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            if len(self.price_history) >= 2:
                oldest_price = self.price_history[0]['price']
                newest_price = self.price_history[-1]['price']
                total_change = (newest_price - oldest_price) / oldest_price * 100
                print(f"üí∞ Price change overall: {total_change:.4f}% ({oldest_price} -> {newest_price})")
        
        # –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï: –¥–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏
        if len(self.price_history) > 0:
            last_time = self.price_history[-1]['timestamp']
            time_diff = (current_time - last_time).total_seconds()
            if time_diff < 0.5:  # –ù–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ 0.5 —Å–µ–∫—É–Ω–¥—ã
                return None
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ
        self.price_history.append({
            'timestamp': current_time,
            'price': current_price,
            'features': features.copy()
        })
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –¥–æ 200 –∑–∞–ø–∏—Å–µ–π (–£–ú–ï–ù–¨–®–ï–ù–û –¥–ª—è —Ç–µ—Å—Ç–∞)
        if len(self.price_history) > 200:
            self.price_history = self.price_history[-200:]
        
        # –†–ê–°–ß–ï–¢ TARGET: –¥–ª—è –∑–∞–ø–∏—Å–µ–π —Å—Ç–∞—Ä—à–µ 20 —Å–µ–∫—É–Ω–¥
        twenty_sec_ago = current_time - timedelta(seconds=20)
        
        targets_calculated = 0
        for i, data_point in enumerate(self.price_history):
            if data_point['timestamp'] <= twenty_sec_ago:
                if 'target' not in data_point['features']:
                    future_price = current_price
                    current_price_at_time = data_point['price']
                    
                    target = self.calculate_target(current_price_at_time, future_price)
                    data_point['features']['target'] = target
                    self.target_calculated_count += 1
                    targets_calculated += 1
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –í–°–ï target —Ä–∞—Å—á–µ—Ç—ã –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                    price_change = (future_price - current_price_at_time) / current_price_at_time * 100
                    print(f"üéØ TARGET CALCULATED: {target} (change: {price_change:.4f}%) - {current_price_at_time} -> {future_price}")
        
        if targets_calculated > 0:
            print(f"‚úÖ Calculated {targets_calculated} new targets, total: {self.target_calculated_count}")
            
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ñ–∏—á–∏ —Å target
            for data_point in reversed(self.price_history):
                if 'target' in data_point['features']:
                    return data_point['features']
        
        return None
    
    def get_all_features(self, order_book_data, trade_data, ticker_data):
        """–°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Ñ–∏—á–∏ –≤–º–µ—Å—Ç–µ (—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã)"""
        
        # –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï –ß–ê–°–¢–û–¢–´: –æ–±–Ω–æ–≤–ª—è–µ–º –Ω–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
        if not self.should_update_features():
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ñ–∏—á–∏ –≤–º–µ—Å—Ç–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö
            if self.price_history:
                return self.price_history[-1]['features']
            else:
                return self.create_empty_features()
        
        self.update_cumulative_delta(trade_data)
        
        current_price = self.get_current_price(ticker_data)
        
        features = {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': self.calculate_order_book_imbalance(order_book_data),
            'spread_percent': self.calculate_spread(order_book_data),
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': self.extract_funding_rate(ticker_data),
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': current_price,
            'target': 0
        }
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏ –ø–æ–ª—É—á–∞–µ–º —Ñ–∏—á–∏ —Å target (–µ—Å–ª–∏ –µ—Å—Ç—å)
        updated_features = self.update_price_history(current_price, features)
        if updated_features:
            return updated_features
        
        return features
    
    def create_empty_features(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø—É—Å—Ç—ã–µ —Ñ–∏—á–∏ –∫–æ–≥–¥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ"""
        return {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': 0.5,
            'spread_percent': 0,
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': 0,
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': 0,
            'target': 0
        }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
feature_engine = FeatureEngine()


===== main.py =====


# main.py
from data_collector import data_collector
from data_monitor import DataMonitor
import time

def main():
    print("üöÄ Quantum Bot Starting...")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
    data_collector.start()
    
    # –ú–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    monitor = DataMonitor()
    
    # –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
    try:
        last_progress_check = 0
        
        while True:
            current_time = time.time()
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
            if current_time - last_progress_check > 120:
                monitor.print_progress_report()
                last_progress_check = current_time
            
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nüõë Bot stopped")

if __name__ == "__main__":
    main()


===== train_model.py =====


# train_model.py
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
from sklearn.metrics import classification_report, accuracy_score
import joblib
import os

def load_training_data():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
    data_file = "data/training_data.csv"
    
    if not os.path.exists(data_file):
        print("‚ùå –§–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ.")
        return None
    
    df = pd.read_csv(data_file)
    print(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(df)} –∑–∞–ø–∏—Å–µ–π")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ target
    if 'target' not in df.columns or df['target'].isna().all():
        print("‚ùå –ù–µ—Ç —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (target). –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö.")
        return None
    
    # –£–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –±–µ–∑ target
    df = df.dropna(subset=['target'])
    df['target'] = df['target'].astype(int)
    
    print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {len(df)}")
    print(f"üìà –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target: {df['target'].value_counts().to_dict()}")
    
    return df

def create_baseline_model(df):
    """–°–æ–∑–¥–∞–µ—Ç –±–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–∞–≤–∏–ª"""
    print("\nü§ñ –ë–ï–ô–ó–õ–ê–ô–ù –ú–û–î–ï–õ–¨ (–ø—Ä–∞–≤–∏–ª–∞):")
    
    # –ü—Ä–∞–≤–∏–ª–æ 1: Imbalance > 0.6 = –ø–æ–∫—É–ø–∞—Ç—å
    df['baseline_imbalance'] = (df['order_book_imbalance'] > 0.6).astype(int)
    accuracy_imbalance = accuracy_score(df['target'] == 1, df['baseline_imbalance'])
    print(f"üìä Imbalance > 0.6 accuracy: {accuracy_imbalance:.3f}")
    
    # –ü—Ä–∞–≤–∏–ª–æ 2: Delta > 0 = –ø–æ–∫—É–ø–∞—Ç—å
    df['baseline_delta'] = (df['cumulative_delta'] > 0).astype(int)
    accuracy_delta = accuracy_score(df['target'] == 1, df['baseline_delta'])
    print(f"üìà Delta > 0 accuracy: {accuracy_delta:.3f}")
    
    # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ
    df['baseline_combined'] = ((df['order_book_imbalance'] > 0.6) & 
                              (df['cumulative_delta'] > 0)).astype(int)
    accuracy_combined = accuracy_score(df['target'] == 1, df['baseline_combined'])
    print(f"üéØ Combined rule accuracy: {accuracy_combined:.3f}")

def train_ml_model(df):
    """–û–±—É—á–∞–µ—Ç ML –º–æ–¥–µ–ª—å"""
    print("\nüß† –û–ë–£–ß–ï–ù–ò–ï ML –ú–û–î–ï–õ–ò...")
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –º–æ–¥–µ–ª–∏
    feature_columns = [
        'order_book_imbalance',
        'spread_percent', 
        'cumulative_delta',
        'funding_rate',
        'buy_trades',
        'sell_trades',
        'total_trades'
    ]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    missing_features = [f for f in feature_columns if f not in df.columns]
    if missing_features:
        print(f"‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏: {missing_features}")
        return None
    
    X = df[feature_columns]
    y = df['target']
    
    # –£–±–∏—Ä–∞–µ–º NaN
    mask = ~X.isna().any(axis=1)
    X = X[mask]
    y = y[mask]
    
    print(f"üìä –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è: {len(X)} –∑–∞–ø–∏—Å–µ–π")
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ä—è–¥–∞–º–∏
    tscv = TimeSeriesSplit(n_splits=5)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
    scores = cross_val_score(model, X, y, cv=tscv, scoring='accuracy')
    print(f"üìä –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è accuracy: {scores.mean():.3f} (+/- {scores.std() * 2:.3f})")
    
    # –û–±—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –º–æ–¥–µ–ª–∏
    model.fit(X, y)
    print("‚úÖ –ú–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–∞!")
    
    # –í–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    feature_importance = pd.DataFrame({
        'feature': feature_columns,
        'importance': model.feature_importances_
    }).sort_values('importance', ascending=False)
    
    print("\nüéØ –í–ê–ñ–ù–û–°–¢–¨ –ü–†–ò–ó–ù–ê–ö–û–í:")
    for _, row in feature_importance.iterrows():
        print(f"  {row['feature']}: {row['importance']:.3f}")
    
    return model

def save_model(model, filename="models/quant_model.pkl"):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å"""
    os.makedirs("models", exist_ok=True)
    joblib.dump(model, filename)
    print(f"üíæ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

def main():
    print("üöÄ –ó–ê–ü–£–°–ö –û–ë–£–ß–ï–ù–ò–Ø –ú–û–î–ï–õ–ò...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    df = load_training_data()
    if df is None or len(df) < 50:
        print(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è. –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 50 –∑–∞–ø–∏—Å–µ–π, —Å–µ–π—á–∞—Å: {len(df) if df is not None else 0}")
        return
    
    # –ë–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å
    create_baseline_model(df)
    
    # ML –º–æ–¥–µ–ª—å (–µ—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö)
    if len(df) >= 50:
        model = train_ml_model(df)
        if model:
            save_model(model)
            print("\nüéâ –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.")
    else:
        print(f"üìä –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö. –°–µ–π—á–∞—Å: {len(df)}/50")

if __name__ == "__main__":
    main()
