

===== config.py =====


# config.py - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –≤—Ö–æ–¥–∞
SYMBOL = "BTC-USDT-SWAP"
BUCKET_SECONDS = 60.0  # –∏–Ω—Ç–µ—Ä–≤–∞–ª –∞–Ω–∞–ª–∏–∑–∞ (—Å–µ–∫—É–Ω–¥—ã)

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
IMBALANCE_THRESHOLD = 0.35
DELTA_THRESHOLD = 8.0


===== data_collector.py =====


# data_collector.py - –¢–û–õ–¨–ö–û LIVE OKX
import json
import threading
import websocket
import time
from datetime import datetime
from config import SYMBOL

class LiveDataCollector:
    def __init__(self):
        self.price = None
        self.best_bid = None
        self.best_ask = None
        self.spread = None
        self.bids = []
        self.asks = []
        self.trades = []
        
        self.lock = threading.Lock()
        self._ws = None
        self.connected = False

        print("[Collector] Starting OKX WebSocket connection...")
        self._start_ws()

    def _start_ws(self):
        url = "wss://ws.okx.com:8443/ws/v5/public"
        self._ws = websocket.WebSocketApp(
            url,
            on_open=self._on_open,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close
        )

        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        self.ws_thread = threading.Thread(target=self._ws.run_forever, daemon=True)
        self.ws_thread.start()

    def _on_open(self, ws):
        print("[Collector] ‚úÖ Connected to OKX WebSocket")
        self.connected = True
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å—Ç–∞–∫–∞–Ω –∏ —Ç—Ä–µ–π–¥—ã
        sub_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "books5", "instId": SYMBOL},
                {"channel": "trades", "instId": SYMBOL}
            ]
        }
        ws.send(json.dumps(sub_msg))
        print("[Collector] ‚úÖ Subscribed to books5 & trades")

    def _on_error(self, ws, error):
        print(f"[Collector] ‚ùå WebSocket error: {error}")
        self.connected = False

    def _on_close(self, ws, close_status_code, close_msg):
        print(f"[Collector] üîå WebSocket closed: {close_status_code} - {close_msg}")
        self.connected = False

    def _on_message(self, ws, message):
        try:
            msg = json.loads(message)
            
            if "event" in msg:
                if msg["event"] == "subscribe":
                    print(f"[Collector] ‚úÖ Subscribed to: {msg.get('arg', {})}")
                return

            if "arg" not in msg:
                return

            channel = msg["arg"]["channel"]

            with self.lock:
                if channel == "books5" and "data" in msg:
                    self._handle_books(msg["data"][0])
                elif channel == "trades" and "data" in msg:
                    self._handle_trades(msg["data"])
                    
        except Exception as e:
            print(f"[Collector] ‚ùå Message processing error: {e}")

    def _handle_books(self, book_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞–∫–∞–Ω"""
        try:
            self.bids = book_data.get("bids", [])
            self.asks = book_data.get("asks", [])
            
            if self.bids and self.asks:
                self.best_bid = float(self.bids[0][0])
                self.best_ask = float(self.asks[0][0])
                self.price = (self.best_bid + self.best_ask) / 2
                self.spread = self.best_ask - self.best_bid
                
        except Exception as e:
            print(f"[Collector] ‚ùå Book processing error: {e}")

    def _handle_trades(self, trades_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–π–¥—ã"""
        try:
            self.trades = trades_data[-10:]  # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ç—Ä–µ–π–¥–æ–≤
        except Exception as e:
            print(f"[Collector] ‚ùå Trade processing error: {e}")

    def get_snapshot(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Å–Ω–∞–ø—à–æ—Ç –¥–∞–Ω–Ω—ã—Ö"""
        with self.lock:
            return {
                "order_book": {
                    "bids": self.bids,
                    "asks": self.asks,
                    "ts": datetime.utcnow().isoformat()
                },
                "trades": self.trades,
                "price": self.price,
                "spread": self.spread,
                "connected": self.connected
            }

    def stop(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if self._ws:
            self._ws.close()
        self.connected = False


===== feature_engine.py =====


from collections import deque
import time
from datetime import datetime

class FeatureEngine:
    def __init__(self):
        self.delta_deque = deque()
        self.imbalance_history = deque(maxlen=2)
        self.last_price = 60000.0
        self.delta_window_sec = 300  # 5 –º–∏–Ω—É—Ç –¥–ª—è –¥–µ–ª—å—Ç—ã

    def _clean_old(self, now_ts):
        cutoff = now_ts - self.delta_window_sec
        while self.delta_deque and self.delta_deque[0][0] < cutoff:
            self.delta_deque.popleft()

    def _calculate_imbalance(self, bids, asks):
        bid_vol = sum(float(b[1]) for b in bids[:3] if len(b) >= 2)
        ask_vol = sum(float(a[1]) for a in asks[:3] if len(a) >= 2)
        if (bid_vol + ask_vol) > 0:
            return bid_vol / (bid_vol + ask_vol)
        return 0.5

    def update_from_snapshot(self, snapshot):
        now = time.time()
        ob = snapshot.get("order_book") or {}
        trades = snapshot.get("trades") or []

        current_imbalance = 0.5
        spread_pct = 0.0

        if ob:
            bids = ob.get("bids", [])
            asks = ob.get("asks", [])

            current_imbalance = self._calculate_imbalance(bids, asks)
            self.imbalance_history.append(current_imbalance)

            try:
                if bids and asks:
                    best_bid = float(bids[0][0])
                    best_ask = float(asks[0][0])
                    if best_ask > best_bid:
                        spread_pct = (best_ask - best_bid) / ((best_ask + best_bid) / 2) * 100.0
                        self.last_price = (best_ask + best_bid) / 2
            except:
                pass

        if len(self.imbalance_history) >= 2:
            imb_trend = "rising" if current_imbalance > list(self.imbalance_history)[-2] else "falling"
        else:
            imb_trend = "flat"

        # Update delta from trades
        for t in trades:
            side = t.get("side", "buy")
            sz = float(t.get("sz", 0)) if t.get("sz") else 0.0
            signed = sz if side == "buy" else -sz
            self.delta_deque.append((now, signed))

        self._clean_old(now)
        cumulative_delta = sum(x[1] for x in self.delta_deque)
        delta_per_minute = cumulative_delta / 5.0 if cumulative_delta != 0 else 0.0

        features = {
            "timestamp": datetime.utcnow().isoformat(),
            "order_book_imbalance": round(current_imbalance, 4),
            "imbalance_trend": imb_trend,
            "cumulative_delta": round(cumulative_delta, 6),
            "delta_per_minute": round(delta_per_minute, 2),
            "spread_percent": round(spread_pct, 6),
            "current_price": round(self.last_price, 2)
        }
        return features

feature_engine = FeatureEngine()


===== main.py =====


import time
from data_collector import LiveDataCollector
from feature_engine import feature_engine
from simple_strategy import SimpleStrategy
from telegram_notifier import telegram
from config import BUCKET_SECONDS

def run_bot():
    print("Bot starting...")
    telegram.send_bot_status("start")

    collector = LiveDataCollector()
    strat = SimpleStrategy()

    time.sleep(5)
    print("Bot is running...")

    try:
        while True:
            snapshot = collector.get_snapshot()
            if not snapshot.get("connected", False):
                time.sleep(1)
                continue

            features = feature_engine.update_from_snapshot(snapshot)
            result = strat.analyze(features)

            if result["action"] == "ENTER":
                side = result["side"]
                price = result["price"]
                strat.record_entry(side, price)
                telegram.send_trade_signal(side, price)
                print(f"Signal: {side} at price {price:.2f}")

            time.sleep(BUCKET_SECONDS)

    except KeyboardInterrupt:
        print("Bot stopped")
        telegram.send_bot_status("stop")

if __name__ == "__main__":
    run_bot()


===== simple_strategy.py =====


import time
from config import IMBALANCE_THRESHOLD, DELTA_THRESHOLD

class SimpleStrategy:
    """
    –õ—ë–≥–∫–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è: —Ç–æ–ª—å–∫–æ –≤—Ö–æ–¥–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
    """

    def __init__(self):
        self.open_position = None  # {"side","entry_price","entry_ts"}
    
    def analyze(self, features):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: {action, side, price, reason}"""
        imb = features.get("order_book_imbalance", 0.5)
        delta_value = features.get("cumulative_delta", 0.0)
        trend = features.get("imbalance_trend", "flat")
        price = features.get("current_price", 0.0)

        if self.open_position is None:
            # SHORT —Å–∏–≥–Ω–∞–ª
            if imb < (1 - IMBALANCE_THRESHOLD) and delta_value < -DELTA_THRESHOLD and trend == "falling":
                return {
                    "action": "ENTER",
                    "side": "SHORT",
                    "price": price,
                    "reason": "strong_short_signal"
                }
            # LONG —Å–∏–≥–Ω–∞–ª
            if imb > IMBALANCE_THRESHOLD and delta_value > DELTA_THRESHOLD and trend == "rising":
                return {
                    "action": "ENTER",
                    "side": "LONG",
                    "price": price,
                    "reason": "strong_long_signal"
                }

        return {"action": "HOLD", "reason": "no_signal"}

    def record_entry(self, side, price):
        self.open_position = {
            "side": side,
            "entry_price": price,
            "entry_ts": time.time()
        }


===== telegram_notifier.py =====


# telegram_notifier.py
import requests
import os

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")

class TelegramNotifier:
    def __init__(self):
        self.enabled = bool(TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID)
        print(f"[Telegram] Enabled: {self.enabled}")

    def _send_message(self, message):
        if not self.enabled:
            return
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            payload = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
            requests.post(url, json=payload, timeout=5)
        except:
            pass

    def send_bot_status(self, status):
        self._send_message(status)

    def send_trade_signal(self, side, price):
        self._send_message(f"{side.lower()} {price:.2f}")

telegram = TelegramNotifier()