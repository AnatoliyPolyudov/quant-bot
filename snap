

===== config.py =====


# config.py - –§–ò–ö–°–ò–†–£–ï–ú –ì–õ–ê–í–ù–£–Æ –ü–†–û–ë–õ–ï–ú–£ –í–´–•–û–î–û–í
from pathlib import Path

ROOT = Path(__file__).parent

# –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã
MODE = "live"  # –¢–û–õ–¨–ö–û live —Ä–µ–∂–∏–º

# –ë–∏—Ä–∂–∞ –∏ —Å–∏–º–≤–æ–ª
EXCHANGE = "OKX"
SYMBOL = "BTC-USDT-SWAP"

# –¢–∞–π–º–∏–Ω–≥–∏ –î–õ–Ø –£–ú–ù–´–• –í–´–•–û–î–û–í
BUCKET_SECONDS = 60.0  # 1 –º–∏–Ω—É—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞
MIN_SIGNAL_INTERVAL = 300.0  # 5 –º–∏–Ω –º–µ–∂–¥—É –≤—Ö–æ–¥–∞–º–∏ (–±—ã–ª–æ 180)
TRADE_HOLD_SECONDS = 180.0  # –ú–ò–ù–ò–ú–£–ú 3 –º–∏–Ω—É—Ç—ã —É–¥–µ—Ä–∂–∞–Ω–∏—è (–±—ã–ª–æ 300)

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ - –°–¢–†–û–ì–ò–ï –ü–û–†–û–ì–ò
IMBALANCE_THRESHOLD = 0.70  # –ë–´–õ–û 0.64 ‚Üí –°–ï–ô–ß–ê–° 0.70
DELTA_THRESHOLD = 8.0  # –ë–´–õ–û 4.5 ‚Üí –°–ï–ô–ß–ê–° 8.0
SPREAD_MAX_PCT = 0.03

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –í–´–•–û–î–ê - –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê
EXIT_IMBALANCE_THRESHOLD = 0.40  # –ñ–µ—Å—Ç–∫–∏–π –ø–æ—Ä–æ–≥ –≤—ã—Ö–æ–¥–∞
EXIT_DELTA_PER_MINUTE = -5.0  # –°–∫–æ—Ä–æ—Å—Ç—å —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –¥–ª—è –≤—ã—Ö–æ–¥–∞
MIN_HOLD_SECONDS = 120.0  # –ú–∏–Ω–∏–º—É–º 2 –º–∏–Ω—É—Ç—ã —É–¥–µ—Ä–∂–∞–Ω–∏—è

# –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
START_EQUITY = 100.0
POSITION_PCT = 0.05

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
LOGS_DIR = ROOT / "logs"
LOGS_DIR.mkdir(exist_ok=True)


===== data_collector.py =====


# data_collector.py - –¢–û–õ–¨–ö–û LIVE OKX
import json
import threading
import websocket
import time
from datetime import datetime
from config import SYMBOL

class LiveDataCollector:
    def __init__(self):
        self.price = None
        self.best_bid = None
        self.best_ask = None
        self.spread = None
        self.bids = []
        self.asks = []
        self.trades = []
        
        self.lock = threading.Lock()
        self._ws = None
        self.connected = False

        print("[Collector] Starting OKX WebSocket connection...")
        self._start_ws()

    def _start_ws(self):
        url = "wss://ws.okx.com:8443/ws/v5/public"
        self._ws = websocket.WebSocketApp(
            url,
            on_open=self._on_open,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close
        )

        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        self.ws_thread = threading.Thread(target=self._ws.run_forever, daemon=True)
        self.ws_thread.start()

    def _on_open(self, ws):
        print("[Collector] ‚úÖ Connected to OKX WebSocket")
        self.connected = True
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å—Ç–∞–∫–∞–Ω –∏ —Ç—Ä–µ–π–¥—ã
        sub_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "books5", "instId": SYMBOL},
                {"channel": "trades", "instId": SYMBOL}
            ]
        }
        ws.send(json.dumps(sub_msg))
        print("[Collector] ‚úÖ Subscribed to books5 & trades")

    def _on_error(self, ws, error):
        print(f"[Collector] ‚ùå WebSocket error: {error}")
        self.connected = False

    def _on_close(self, ws, close_status_code, close_msg):
        print(f"[Collector] üîå WebSocket closed: {close_status_code} - {close_msg}")
        self.connected = False

    def _on_message(self, ws, message):
        try:
            msg = json.loads(message)
            
            if "event" in msg:
                if msg["event"] == "subscribe":
                    print(f"[Collector] ‚úÖ Subscribed to: {msg.get('arg', {})}")
                return

            if "arg" not in msg:
                return

            channel = msg["arg"]["channel"]

            with self.lock:
                if channel == "books5" and "data" in msg:
                    self._handle_books(msg["data"][0])
                elif channel == "trades" and "data" in msg:
                    self._handle_trades(msg["data"])
                    
        except Exception as e:
            print(f"[Collector] ‚ùå Message processing error: {e}")

    def _handle_books(self, book_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞–∫–∞–Ω"""
        try:
            self.bids = book_data.get("bids", [])
            self.asks = book_data.get("asks", [])
            
            if self.bids and self.asks:
                self.best_bid = float(self.bids[0][0])
                self.best_ask = float(self.asks[0][0])
                self.price = (self.best_bid + self.best_ask) / 2
                self.spread = self.best_ask - self.best_bid
                
        except Exception as e:
            print(f"[Collector] ‚ùå Book processing error: {e}")

    def _handle_trades(self, trades_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–π–¥—ã"""
        try:
            self.trades = trades_data[-10:]  # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ç—Ä–µ–π–¥–æ–≤
        except Exception as e:
            print(f"[Collector] ‚ùå Trade processing error: {e}")

    def get_snapshot(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Å–Ω–∞–ø—à–æ—Ç –¥–∞–Ω–Ω—ã—Ö"""
        with self.lock:
            return {
                "order_book": {
                    "bids": self.bids,
                    "asks": self.asks,
                    "ts": datetime.utcnow().isoformat()
                },
                "trades": self.trades,
                "price": self.price,
                "spread": self.spread,
                "connected": self.connected
            }

    def stop(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if self._ws:
            self._ws.close()
        self.connected = False


===== feature_engine.py =====


# feature_engine.py - –ë–´–°–¢–†–´–ô –¢–†–ï–ù–î –î–õ–Ø 2 –ú–ò–ù–£–¢
from collections import deque
import time
from datetime import datetime

class FeatureEngine:
    def __init__(self):
        self.delta_deque = deque()
        self.imbalance_history = deque(maxlen=2)  # –¢–û–õ–¨–ö–û 2 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞
        self.trade_counts = {"buy": 0, "sell": 0}
        self.last_price = 60000.0
        self.delta_window_sec = 300  # 5 –º–∏–Ω—É—Ç –¥–ª—è –¥–µ–ª—å—Ç—ã

    def _clean_old(self, now_ts):
        cutoff = now_ts - self.delta_window_sec
        while self.delta_deque and self.delta_deque[0][0] < cutoff:
            self.delta_deque.popleft()

    def _calculate_imbalance(self, bids, asks):
        """–†–∞—Å—á–µ—Ç –∏–º–±–∞–ª–∞–Ω—Å–∞ –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞"""
        bid_vol = 0.0
        ask_vol = 0.0
        
        for b in bids[:3]:
            try:
                if len(b) >= 2:
                    bid_vol += float(b[1])
            except:
                pass
                
        for a in asks[:3]:
            try:
                if len(a) >= 2:
                    ask_vol += float(a[1])
            except:
                pass
                
        if (bid_vol + ask_vol) > 0:
            return bid_vol / (bid_vol + ask_vol)
        return 0.5

    def update_from_snapshot(self, snapshot):
        now = time.time()
        ob = snapshot.get("order_book") or {}
        trades = snapshot.get("trades") or []

        # Imbalance and spread
        current_imbalance = 0.5
        spread_pct = 0.0
        
        if ob:
            bids = ob.get("bids", [])
            asks = ob.get("asks", [])
            
            # Calculate current imbalance
            current_imbalance = self._calculate_imbalance(bids, asks)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞ (2 –∑–Ω–∞—á–µ–Ω–∏—è)
            self.imbalance_history.append(current_imbalance)
            
            # Calculate spread
            try:
                if bids and asks:
                    best_bid = float(bids[0][0])
                    best_ask = float(asks[0][0])
                    if best_ask > best_bid:
                        spread_pct = (best_ask - best_bid) / ((best_ask + best_bid) / 2) * 100.0
                        self.last_price = (best_ask + best_bid) / 2
            except:
                pass

        # –ë–´–°–¢–†–´–ô –¢–†–ï–ù–î - –ø–æ 2 –ø–æ—Å–ª–µ–¥–Ω–∏–º –∑–Ω–∞—á–µ–Ω–∏—è–º
        if len(self.imbalance_history) >= 2:
            imb_trend = "rising" if current_imbalance > list(self.imbalance_history)[-2] else "falling"
        else:
            imb_trend = "flat"

        # Update delta from trades
        for t in trades:
            side = t.get("side", "buy")
            try:
                sz = float(t.get("sz", 0))
            except:
                sz = 0.0
                
            signed = sz if side == "buy" else -sz
            self.delta_deque.append((now, signed))
            
            if side == "buy":
                self.trade_counts["buy"] += 1
            else:
                self.trade_counts["sell"] += 1

        # Clean old trades and calculate cumulative delta
        self._clean_old(now)
        cumulative_delta = sum(x[1] for x in self.delta_deque)
        
        # –î–µ–ª—å—Ç–∞ –≤ –º–∏–Ω—É—Ç—É (–Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è)
        delta_per_minute = cumulative_delta / 5.0 if cumulative_delta != 0 else 0.0

        features = {
            "timestamp": datetime.utcnow().isoformat(),
            "order_book_imbalance": round(current_imbalance, 4),
            "imbalance_trend": imb_trend,  # –ë–´–°–¢–†–´–ô —Ç—Ä–µ–Ω–¥
            "cumulative_delta": round(cumulative_delta, 6),
            "delta_per_minute": round(delta_per_minute, 2),
            "spread_percent": round(spread_pct, 6),
            "buy_trades": self.trade_counts["buy"],
            "sell_trades": self.trade_counts["sell"],
            "current_price": round(self.last_price, 2)
        }
        return features

# Global instance
feature_engine = FeatureEngine()


===== live_executor.py =====


# live_executor.py
"""
Live executor for OKX (USDT-Margined Perpetuals).
SAFE BY DEFAULT: DRY_RUN = True.
Use with care. Test in sandbox first.
Requires 'requests'.
"""
import os
import time
import json
import hmac
import base64
import hashlib
import requests
import csv
from datetime import datetime
from decimal import Decimal, ROUND_DOWN

from config import SYMBOL, LOGS_DIR, START_EQUITY, POSITION_PCT

# Env vars: set OKX_API_KEY, OKX_API_SECRET, OKX_API_PASSPHRASE for live mode
API_KEY = os.getenv("OKX_API_KEY", "")
API_SECRET = os.getenv("OKX_API_SECRET", "")
API_PASSPHRASE = os.getenv("OKX_API_PASSPHRASE", "")

# Safety defaults
DRY_RUN = True
MIN_NOTIONAL_USDT = 5.0
OKX_API_BASE = "https://www.okx.com"
OKX_MARKET_TICKER = "/api/v5/market/ticker"
OKX_TRADE_ORDER = "/api/v5/trade/order"
OKX_ACCOUNT_POSITIONS = "/api/v5/account/positions"

LOGFILE = LOGS_DIR / "live_trades.csv"
if not LOGFILE.exists():
    with open(LOGFILE, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["ts","mode","action","side","price","size_contracts","notional_usdt","note","api_response"])

def _now_iso():
    return datetime.utcnow().isoformat() + "Z"

def _sign(timestamp: str, method: str, request_path: str, body: str, secret: str):
    message = timestamp + method.upper() + request_path + (body or "")
    mac = hmac.new(bytes(secret, "utf-8"), bytes(message, "utf-8"), digestmod=hashlib.sha256)
    return base64.b64encode(mac.digest()).decode()

def _request(method: str, path: str, params=None, body: dict=None, timeout=10.0):
    url = OKX_API_BASE + path
    method = method.upper()
    ts = datetime.utcnow().isoformat() + "Z"
    body_str = json.dumps(body) if body else ""
    if API_KEY and API_SECRET and API_PASSPHRASE:
        sign = _sign(ts, method, path, body_str, API_SECRET)
        headers = {
            "OK-ACCESS-KEY": API_KEY,
            "OK-ACCESS-SIGN": sign,
            "OK-ACCESS-TIMESTAMP": ts,
            "OK-ACCESS-PASSPHRASE": API_PASSPHRASE,
            "Content-Type": "application/json"
        }
    else:
        headers = {"Content-Type": "application/json"}

    try:
        if method == "GET":
            r = requests.get(url, params=params, headers=headers, timeout=timeout)
        else:
            r = requests.post(url, params=params, data=body_str, headers=headers, timeout=timeout)
        return r
    except Exception as e:
        return None

def log_row(mode, action, side, price, size_contracts, notional_usdt, note, api_response):
    ts = datetime.utcnow().isoformat()
    with open(LOGFILE, "a", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([ts, mode, action, side, price, size_contracts, notional_usdt, note, json.dumps(api_response)])
    print(f"[{ts}] {mode} {action} {side} price={price} size={size_contracts} notional={notional_usdt} note={note}")

class LiveExecutor:
    def __init__(self, dry_run=True):
        # If API keys are not set, force dry_run
        self.dry_run = dry_run or (API_KEY == "" or API_SECRET == "" or API_PASSPHRASE == "")
        if self.dry_run:
            print("LIVE EXECUTOR: DRY_RUN mode (no real orders).")
        else:
            print("LIVE EXECUTOR: LIVE mode (orders WILL be sent).")
        self.session = requests.Session()

    def get_price(self, instId):
        params = {"instId": instId}
        r = _request("GET", OKX_MARKET_TICKER, params=params)
        if not r or r.status_code != 200:
            return None
        try:
            data = r.json()
            if data.get("code") == "0" and data.get("data"):
                rec = data["data"][0]
                return float(rec.get("last"))
            return None
        except Exception:
            return None

    def _place_market_order(self, instId, side, sz_contracts, tdMode="cross", reduceOnly=False):
        body = {
            "instId": instId,
            "side": side,
            "ordType": "market",
            "sz": str(sz_contracts),
            "tdMode": tdMode
        }
        if reduceOnly:
            body["reduceOnly"] = True

        if self.dry_run:
            resp = {"sim": True, "body": body}
            log_row("DRY", "ORDER", side, None, sz_contracts, None, "simulated_market_order", resp)
            return resp

        r = _request("POST", OKX_TRADE_ORDER, body=body)
        if r is None:
            log_row("ERR", "ORDER", side, None, sz_contracts, None, "http_error", {})
            return None
        try:
            resp = r.json()
        except Exception:
            resp = {"status_code": r.status_code, "text": r.text}
        log_row("LIVE", "ORDER", side, None, sz_contracts, None, "okx_resp", resp)
        return resp

    def enter_position_notional(self, side, notional_usdt):
        notional_usdt = float(notional_usdt)
        if notional_usdt < MIN_NOTIONAL_USDT:
            print("Notional below minimum:", notional_usdt)
            return None

        price = self.get_price(SYMBOL)
        if not price:
            print("Failed to fetch price; abort enter")
            return None

        size = Decimal(notional_usdt / price).quantize(Decimal("0.000001"), rounding=ROUND_DOWN)
        if size <= 0:
            print("Calculated size zero; abort")
            return None

        resp = self._place_market_order(SYMBOL, "buy" if side.upper()=="LONG" else "sell", str(size))
        return {"price": price, "size": float(size), "resp": resp, "notional": notional_usdt}

    def exit_position_market(self):
        if self.dry_run:
            resp = {"sim": True, "note": "simulated_exit"}
            log_row("DRY", "EXIT", "BOTH", None, None, None, "simulated_exit", resp)
            return resp

        # live exit: query positions (user must adapt if OKX returns unexpected structure)
        params = {"instId": SYMBOL}
        r = _request("GET", OKX_ACCOUNT_POSITIONS, params=params)
        if not r or r.status_code != 200:
            print("Failed to query positions")
            return None
        try:
            data = r.json()
        except Exception:
            data = None
        log_row("LIVE", "EXIT", "BOTH", None, None, None, "position_query", data)
        return data

    def safe_enter_from_equity_pct(self, side, pct):
        equity = START_EQUITY
        notional = equity * pct
        return self.enter_position_notional(side, notional)


===== main.py =====


# main.py - –° TELEGRAM –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø–ú–ò
import time
from data_collector import LiveDataCollector
from feature_engine import FeatureEngine
from simple_strategy import SimpleStrategy
from live_executor import LiveExecutor
from telegram_notifier import telegram
from config import MODE, BUCKET_SECONDS, POSITION_PCT, IMBALANCE_THRESHOLD, DELTA_THRESHOLD


def run_bot():
    print(f"üöÄ Starting Quantum Bot LITE v1.0 - LIVE MODE")
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ Telegram
    telegram.send_bot_status("STARTING", "1.0")

    print(f"üìà Symbol: BTC-USDT-SWAP")
    print(f"‚è∞ Timeframe: 1-MINUTE ANALYSIS") 
    print(f"üí∞ Equity: $100, Position: {POSITION_PCT*100}%")
    print(f"‚ö° Strategy: imb>{IMBALANCE_THRESHOLD}, delta>{DELTA_THRESHOLD}")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π
    collector = LiveDataCollector()
    fe = FeatureEngine()
    strat = SimpleStrategy()
    executor = LiveExecutor(dry_run=False)  # LIVE TRADING!

    last_bucket = 0
    startup_delay = 5  # –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ WebSocket

    print(f"‚è≥ Waiting {startup_delay}s for WebSocket connection...")
    time.sleep(startup_delay)

    try:
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —á—Ç–æ –±–æ—Ç –∑–∞–ø—É—â–µ–Ω
        telegram.send_bot_status("RUNNING", "1.0")
        
        while True:
            now = time.time()

            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ö–ê–ñ–î–£–Æ –ú–ò–ù–£–¢–£
            if now - last_bucket >= BUCKET_SECONDS:
                snapshot = collector.get_snapshot()
                
                if not snapshot.get("connected", False):
                    print("‚ùå WebSocket not connected, retrying...")
                    time.sleep(1)
                    continue

                features = fe.update_from_snapshot(snapshot)
                last_bucket = now

                # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç—É—Å –° –û–ë–ù–û–í–õ–ï–ù–ù–´–ú–ò –ú–ï–¢–†–ò–ö–ê–ú–ò
                print("\n" + "="*60)
                print(f"üìä {features['timestamp'][11:19]} | Price: ${features['current_price']:.2f}")
                print(f"üìà Imbalance: {features['order_book_imbalance']:.3f} | Trend: {features['imbalance_trend']}")
                print(f"üìä Delta: {features['cumulative_delta']:.1f} ({features['delta_per_minute']:.1f}/min)")
                print(f"üéØ Spread: {features['spread_percent']:.4f}%")
                
                # –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                result = strat.analyze(features)
                print(f"ü§ñ Strategy: {result['action']} - {result.get('reason', '')}")

                # –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
                if result["action"] == "ENTER":
                    print(f"üí∞ ENTER {result['side']} SIGNAL!")
                    notional_pct = POSITION_PCT
                    order_result = executor.safe_enter_from_equity_pct(result["side"], notional_pct)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–∏
                    if order_result:
                        telegram.send_trade_executed(
                            action="ENTER",
                            side=result["side"],
                            price=result["price"],
                            size=result.get("size", 0),
                            notional=result.get("notional", 0),
                            order_id=order_result.get("resp", {}).get("data", [{}])[0].get("ordId") if order_result.get("resp") else "SIMULATED"
                        )
                    
                    strat.record_entry(result["side"], result["price"], result.get("size"))

                elif result["action"] == "EXIT":
                    print(f"üí∞ EXIT SIGNAL!")
                    exit_result = executor.exit_position_market()
                    strat.record_exit()

            time.sleep(0.1)

    except KeyboardInterrupt:
        print("\nüõë Bot stopped by user")
        telegram.send_bot_status("STOPPED", "1.0")
    except Exception as e:
        error_msg = f"Critical error: {e}"
        print(f"\n‚ùå {error_msg}")
        telegram.send_error(error_msg)
        import traceback
        traceback.print_exc()
    finally:
        collector.stop()
        telegram.send_bot_status("SHUTDOWN", "1.0")
        print("‚úÖ Bot shutdown complete")


if __name__ == '__main__':
    run_bot()


===== simple_strategy.py =====


# simple_strategy.py - –° TELEGRAM –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø–ú–ò
import time
from config import (IMBALANCE_THRESHOLD, DELTA_THRESHOLD, SPREAD_MAX_PCT, 
                   MIN_SIGNAL_INTERVAL, TRADE_HOLD_SECONDS,
                   EXIT_IMBALANCE_THRESHOLD, EXIT_DELTA_PER_MINUTE, MIN_HOLD_SECONDS,
                   POSITION_PCT, START_EQUITY)
from telegram_notifier import telegram

class SimpleStrategy:
    def __init__(self):
        self.last_trade_time = 0
        self.open_position = None  # {"side","entry_ts","entry_price", "size"}
        self.entry_price = 0.0
        self.position_size = 0.0

    def can_trade_now(self):
        return (time.time() - self.last_trade_time) >= MIN_SIGNAL_INTERVAL

    def analyze(self, features):
        imb = features.get("order_book_imbalance", 0.5)
        imb_trend = features.get("imbalance_trend", "flat")
        delta = features.get("cumulative_delta", 0.0)
        delta_rate = features.get("delta_per_minute", 0.0)
        spread = features.get("spread_percent", 999.0)
        price = features.get("current_price", 0.0)

        # Reject if spread large or malformed
        if spread <= 0 or spread > SPREAD_MAX_PCT:
            return {"action": "HOLD", "reason": "spread_bad", "confidence": 0}

        # –ï—Å–ª–∏ –µ—Å—Ç—å –æ—Ç–∫—Ä—ã—Ç–∞—è –ø–æ–∑–∏—Ü–∏—è - –£–ú–ù–ê–Ø –õ–û–ì–ò–ö–ê –í–´–•–û–î–ê
        if self.open_position:
            current_time = time.time()
            position_age = current_time - self.open_position["entry_ts"]
            
            # –ú–ò–ù–ò–ú–ê–õ–¨–ù–û–ï –í–†–ï–ú–Ø –£–î–ï–†–ñ–ê–ù–ò–Ø - –ù–ï –í–´–•–û–î–ò–ú –†–ê–ù–¨–®–ï 2 –ú–ò–ù–£–¢
            if position_age < MIN_HOLD_SECONDS:
                return {"action": "HOLD", "reason": "min_hold_time", "confidence": 0}
            
            # –í–†–ï–ú–ï–ù–ù–û–ô –í–´–•–û–î - –ø–æ—Å–ª–µ 5 –º–∏–Ω—É—Ç
            if position_age >= TRADE_HOLD_SECONDS:
                # –†–∞—Å—á–µ—Ç PnL –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                pnl_pct = ((price - self.entry_price) / self.entry_price * 100) 
                if self.open_position["side"] == "SHORT":
                    pnl_pct = -pnl_pct
                    
                telegram.send_trade_exit(
                    side=self.open_position["side"],
                    entry_price=self.entry_price,
                    exit_price=price,
                    pnl_percent=pnl_pct,
                    hold_time_minutes=position_age / 60
                )
                return {"action": "EXIT", "reason": "time_exit", "side": self.open_position["side"], "price": price}
            
            # –£–ú–ù–´–ô –í–´–•–û–î –ü–û –†–ê–ó–í–û–†–û–¢–£ - –¢–û–õ–¨–ö–û –ü–†–ò –°–ò–ì–ù–ê–õ–ê–•
            if self.open_position["side"] == "LONG":
                # –í—ã—Ö–æ–¥ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –°–ò–õ–¨–ù–û–ú —Ä–∞–∑–≤–æ—Ä–æ—Ç–µ
                if imb < EXIT_IMBALANCE_THRESHOLD and delta_rate < EXIT_DELTA_PER_MINUTE:
                    pnl_pct = ((price - self.entry_price) / self.entry_price * 100)
                    telegram.send_trade_exit(
                        side="LONG",
                        entry_price=self.entry_price,
                        exit_price=price,
                        pnl_percent=pnl_pct,
                        hold_time_minutes=position_age / 60
                    )
                    return {"action": "EXIT", "reason": "strong_reversal", "side": "LONG", "price": price}
                    
            elif self.open_position["side"] == "SHORT":
                # –í—ã—Ö–æ–¥ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –°–ò–õ–¨–ù–û–ú —Ä–∞–∑–≤–æ—Ä–æ—Ç–µ  
                if imb > (1.0 - EXIT_IMBALANCE_THRESHOLD) and delta_rate > -EXIT_DELTA_PER_MINUTE:
                    pnl_pct = ((self.entry_price - price) / self.entry_price * 100)
                    telegram.send_trade_exit(
                        side="SHORT", 
                        entry_price=self.entry_price,
                        exit_price=price,
                        pnl_percent=pnl_pct,
                        hold_time_minutes=position_age / 60
                    )
                    return {"action": "EXIT", "reason": "strong_reversal", "side": "SHORT", "price": price}
            
            return {"action": "HOLD", "reason": "position_open", "confidence": 0}

        # –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏ - –°–¢–†–û–ì–ò–ï –£–°–õ–û–í–ò–Ø –í–•–û–î–ê
        # LONG: –∏–º–±–∞–ª–∞–Ω—Å > 0.70 –ò –¥–µ–ª—å—Ç–∞ > 8.0 –ò —Ç—Ä–µ–Ω–¥ —Ä–∞—Å—Ç—É—â–∏–π
        if (imb > IMBALANCE_THRESHOLD and 
            delta > DELTA_THRESHOLD and 
            imb_trend == "rising" and 
            self.can_trade_now()):
            
            # –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏
            notional = START_EQUITY * POSITION_PCT
            size = notional / price if price > 0 else 0
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª –≤ Telegram
            metrics = {
                "imbalance": imb,
                "delta": delta,
                "trend": imb_trend,
                "delta_per_minute": delta_rate
            }
            telegram.send_trade_signal(
                action="ENTER", 
                side="LONG",
                price=price,
                size=size,
                reason=f"strong_long_imb_{imb}_delta_{delta}",
                metrics=metrics
            )
            
            return {
                "action": "ENTER", 
                "side": "LONG", 
                "price": price,
                "size": size,
                "notional": notional,
                "confidence": 90, 
                "reason": f"strong_long_imb_{imb}_delta_{delta}"
            }
        
        # SHORT: –∏–º–±–∞–ª–∞–Ω—Å < 0.30 –ò –¥–µ–ª—å—Ç–∞ < -8.0 –ò —Ç—Ä–µ–Ω–¥ –ø–∞–¥–∞—é—â–∏–π  
        if (imb < (1.0 - IMBALANCE_THRESHOLD) and 
            delta < -DELTA_THRESHOLD and 
            imb_trend == "falling" and 
            self.can_trade_now()):
            
            # –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏
            notional = START_EQUITY * POSITION_PCT
            size = notional / price if price > 0 else 0
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª –≤ Telegram
            metrics = {
                "imbalance": imb,
                "delta": delta, 
                "trend": imb_trend,
                "delta_per_minute": delta_rate
            }
            telegram.send_trade_signal(
                action="ENTER",
                side="SHORT", 
                price=price,
                size=size,
                reason=f"strong_short_imb_{imb}_delta_{delta}",
                metrics=metrics
            )
            
            return {
                "action": "ENTER", 
                "side": "SHORT", 
                "price": price,
                "size": size, 
                "notional": notional,
                "confidence": 90, 
                "reason": f"strong_short_imb_{imb}_delta_{delta}"
            }

        return {"action": "HOLD", "reason": "no_signal", "confidence": 0}

    def record_entry(self, side, price, size=None):
        if size is None:
            notional = START_EQUITY * POSITION_PCT
            size = notional / price if price > 0 else 0
            
        self.open_position = {
            "side": side, 
            "entry_ts": time.time(), 
            "entry_price": price,
            "size": size
        }
        self.entry_price = price
        self.position_size = size
        self.last_trade_time = time.time()

    def record_exit(self):
        self.open_position = None
        self.entry_price = 0.0
        self.position_size = 0.0
        self.last_trade_time = time.time()


===== telegram_notifier.py =====


# telegram_notifier.py - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import requests
import json
import os
from datetime import datetime

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "8468371553:AAE5XfnFkgkeadWt2M44w8BsiTQ8-7dogFU")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "317217451")

class TelegramNotifier:
    def __init__(self):
        self.token = TELEGRAM_BOT_TOKEN
        self.chat_id = TELEGRAM_CHAT_ID
        self.enabled = bool(TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID)
        
        if self.enabled:
            print("‚úÖ Telegram notifications ENABLED")
        else:
            print("‚ùå Telegram notifications DISABLED - check tokens")

    def _send_message(self, message, parse_mode="HTML"):
        """–ë–∞–∑–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        if not self.enabled:
            return False
            
        try:
            url = f"https://api.telegram.org/bot{self.token}/sendMessage"
            payload = {
                'chat_id': self.chat_id,
                'text': message,
                'parse_mode': parse_mode
            }
            response = requests.post(url, data=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"Telegram error: {e}")
            return False

    def send_trade_signal(self, action, side, price, size, reason, metrics):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ç–æ—Ä–≥–æ–≤–æ–º —Å–∏–≥–Ω–∞–ª–µ"""
        if not self.enabled:
            return
            
        time_str = datetime.utcnow().strftime("%H:%M:%S UTC")
        
        message = f"""
üéØ <b>TRADE SIGNAL</b>
‚è∞ {time_str}
‚ö° <b>{action} {side}</b>

üí∞ Price: ${price:,.2f}
üìä Size: {size:.6f} BTC
üìà Reason: {reason}

<b>METRICS:</b>
üìä Imbalance: {metrics.get('imbalance', 0):.3f}
üìà Delta: {metrics.get('delta', 0):.1f}
üéØ Trend: {metrics.get('trend', 'N/A')}
üîÅ Delta/min: {metrics.get('delta_per_minute', 0):.1f}
        """.strip()

        self._send_message(message)

    def send_trade_executed(self, action, side, price, size, notional, order_id=None):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∏—Å–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Å–¥–µ–ª–∫–µ"""
        if not self.enabled:
            return
            
        time_str = datetime.utcnow().strftime("%H:%M:%S UTC")
        status = "üü¢ LIVE" if order_id and "sim" not in str(order_id) else "üü° DRY RUN"
        
        message = f"""
‚úÖ <b>TRADE EXECUTED</b>
‚è∞ {time_str}
{status}

üîÑ <b>{action} {side}</b>
üí∞ Price: ${price:,.2f}
üìä Size: {size:.6f} BTC
üíµ Notional: ${notional:.2f}

{"üìù Order: " + str(order_id) if order_id else ""}
        """.strip()

        self._send_message(message)

    def send_trade_exit(self, side, entry_price, exit_price, pnl_percent, hold_time_minutes):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≤—ã—Ö–æ–¥–µ –∏–∑ –ø–æ–∑–∏—Ü–∏–∏"""
        if not self.enabled:
            return
            
        time_str = datetime.utcnow().strftime("%H:%M:%S UTC")
        pnl_emoji = "üü¢" if pnl_percent > 0 else "üî¥" if pnl_percent < 0 else "‚ö™"
        side_emoji = "üìà" if side == "LONG" else "üìâ"
        
        message = f"""
üì§ <b>POSITION CLOSED</b>
‚è∞ {time_str}
üïí Hold: {hold_time_minutes:.1f}m

{side_emoji} {side}
üí∞ Entry: ${entry_price:,.2f}
üí∞ Exit: ${exit_price:,.2f}

{pnl_emoji} PnL: {pnl_percent:+.3f}%
        """.strip()

        self._send_message(message)

    def send_error(self, error_message):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"""
        if not self.enabled:
            return
            
        time_str = datetime.utcnow().strftime("%H:%M:%S UTC")
        
        message = f"""
üö® <b>BOT ERROR</b>
‚è∞ {time_str}

‚ùå {error_message}
        """.strip()

        self._send_message(message)

    def send_bot_status(self, status, version="1.0"):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ç–∞—Ç—É—Å–µ –±–æ—Ç–∞"""
        if not self.enabled:
            return
            
        time_str = datetime.utcnow().strftime("%H:%M:%S UTC")
        
        message = f"""
ü§ñ <b>QUANT BOT {version}</b>
‚è∞ {time_str}

üìä Status: <b>{status}</b>
üìç Symbol: BTC-USDT-SWAP
‚è±Ô∏è Timeframe: 1-MINUTE
üîß Mode: LIVE TRADING
        """.strip()

        self._send_message(message)


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å
telegram = TelegramNotifier()
