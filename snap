

===== config.py =====


# config.py - Quantum Bot LITE v1.0 (live-capable, demo by default)
from pathlib import Path

ROOT = Path(__file__).parent

# MODE: "demo" or "live" or "sandbox"
MODE = "demo"            # demo = synthetic data; sandbox/live require keys and adjustments

# Exchange / symbol
EXCHANGE = "OKX"
SYMBOL = "BTC-USDT-SWAP"  # OKX perpetual contract id

# Timing
BUCKET_SECONDS = 1.0         # feature aggregation bucket (seconds)
MIN_SIGNAL_INTERVAL = 30.0   # minimum seconds between real trade signals (protect human)
TRADE_HOLD_SECONDS = 60.0    # time-based exit (seconds)

# Strategy thresholds (tuneable)
IMBALANCE_THRESHOLD = 0.62   # bid/(bid+ask) threshold for long
DELTA_THRESHOLD = 3.0        # rolling signed volume threshold
SPREAD_MAX_PCT = 0.05        # max spread percent allowed (in percent)

# Execution / risk
RISK_PER_TRADE_PCT = 0.3     # percent of equity risked per trade (paper)
START_EQUITY = 70.0          # starting equity default — set to your actual balance for sizing
POSITION_PCT = 0.05          # fraction of equity per position (5% of equity)

# Target / logging
TARGET_HORIZON_SEC = 8
TARGET_THRESHOLD_PCT = 0.03  # 0.03% move considered significant

# Demo generator settings (used in demo MODE)
DEMO_PRICE = 60000.0
DEMO_VOL = 2.0               # price volatility scale

# Windows (fallback)
WINDOWS = {
    "delta_window_sec": 30,
    "volatility_window_sec": 120,
    "depth_aggregation_sec": 3,
    "oi_window_sec": 300
}

# Files & dirs
DATA_DIR = ROOT / "data"
LOGS_DIR = ROOT / "logs"
MODELS_DIR = ROOT / "models"

for d in (DATA_DIR, LOGS_DIR, MODELS_DIR):
    d.mkdir(parents=True, exist_ok=True)


===== data_collector.py =====


import json
import threading
import websocket
import time
from datetime import datetime
from config import SYMBOL, MODE

class LiveDataCollector:
    def __init__(self):
        self.price = None
        self.best_bid = None
        self.best_ask = None
        self.spread = None
        self.delta = 0
        self.last_buy_vol = 0
        self.last_sell_vol = 0
        self.trade_imbalance = 0

        self.trades_buffer = []
        self.lock = threading.Lock()

        self._ws = None

        print("[Collector] Initializing live mode...")
        self._start_ws()

    def _start_ws(self):
        url = "wss://ws.okx.com:8443/ws/v5/public"
        self._ws = websocket.WebSocketApp(
            url,
            on_open=self._on_open,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close
        )

        t = threading.Thread(target=self._ws.run_forever, daemon=True)
        t.start()

    def _on_open(self, ws):
        print("[Collector] Connected to OKX WebSocket")

        sub_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "books5", "instId": SYMBOL},
                {"channel": "trades", "instId": SYMBOL}
            ]
        }
        ws.send(json.dumps(sub_msg))
        print("[Collector] Subscribed to books5 & trades")

    def _on_error(self, ws, error):
        print("[Collector] ERROR:", error)

    def _on_close(self, ws, *args):
        print("[Collector] WebSocket closed")

    def _on_message(self, ws, message):
        msg = json.loads(message)

        if "arg" not in msg:
            return

        channel = msg["arg"]["channel"]

        if channel == "books5":
            self._handle_books(msg)

        elif channel == "trades":
            self._handle_trades(msg)

    def _handle_books(self, msg):
        if "data" not in msg:
            return

        data = msg["data"][0]

        bid = float(data["bids"][0][0])
        ask = float(data["asks"][0][0])

        with self.lock:
            self.best_bid = bid
            self.best_ask = ask
            self.price = (bid + ask) / 2
            self.spread = ask - bid

    def _handle_trades(self, msg):
        if "data" not in msg:
            return

        trades = msg["data"]

        with self.lock:
            for t in trades:
                px = float(t["px"])
                sz = float(t["sz"])
                side = t["side"]  # buy or sell

                if side == "buy":
                    self.last_buy_vol += sz
                else:
                    self.last_sell_vol += sz

            # Calculate imbalance
            total = self.last_buy_vol + self.last_sell_vol
            if total > 0:
                self.trade_imbalance = (self.last_buy_vol - self.last_sell_vol) / total

            # Reset every update to make it short-term impulse
            self.last_buy_vol = 0
            self.last_sell_vol = 0

    def get_snapshot(self):
        with self.lock:
            return {
                "price": self.price,
                "spread": self.spread,
                "imbalance": self.trade_imbalance,
                "ts": time.time()
            }


===== feature_engine.py =====


# feature_engine.py
# Compute 3 features: imbalance (top3), rolling cumulative delta, spread_percent
from collections import deque
import time
from datetime import datetime
from config import WINDOWS, DEMO_PRICE

DELTA_WINDOW_SEC = WINDOWS.get("delta_window_sec", 30)

class FeatureEngine:
    def __init__(self):
        self.delta_deque = deque()
        self.trade_counts = {"buy":0, "sell":0}
        self.last_price = DEMO_PRICE

    def _clean_old(self, now_ts):
        cutoff = now_ts - DELTA_WINDOW_SEC
        while self.delta_deque and self.delta_deque[0][0] < cutoff:
            self.delta_deque.popleft()

    def update_from_snapshot(self, snapshot):
        now = time.time()
        ob = snapshot.get("order_book") or {}
        trades = snapshot.get("trades") or []

        # Imbalance and spread
        imbalance = 0.5
        spread_pct = 0.0
        if ob:
            bids = ob.get("bids", [])
            asks = ob.get("asks", [])
            bid_vol = sum(float(b[1]) for b in bids[:3] if len(b)>=2)
            ask_vol = sum(float(a[1]) for a in asks[:3] if len(a)>=2)
            if (bid_vol + ask_vol) > 0:
                imbalance = bid_vol / (bid_vol + ask_vol)
            try:
                best_bid = float(bids[0][0]) if bids else None
                best_ask = float(asks[0][0]) if asks else None
                if best_bid and best_ask and best_ask > best_bid:
                    spread_pct = (best_ask - best_bid) / ((best_ask + best_bid)/2) * 100.0
                self.last_price = (best_ask + best_bid)/2
            except:
                pass

        # Update delta deque
        for t in trades:
            side = t.get("side", "buy")
            try:
                sz = float(t.get("sz", 0))
            except:
                sz = 0.0
            signed = sz if side == "buy" else -sz
            self.delta_deque.append((now, signed))
            if side == "buy":
                self.trade_counts["buy"] += 1
            else:
                self.trade_counts["sell"] += 1

        self._clean_old(now)
        cumulative_delta = sum(x[1] for x in self.delta_deque)

        features = {
            "timestamp": datetime.utcnow().isoformat(),
            "order_book_imbalance": round(imbalance, 4),
            "spread_percent": round(spread_pct, 6),
            "cumulative_delta": round(cumulative_delta, 6),
            "buy_trades": self.trade_counts["buy"],
            "sell_trades": self.trade_counts["sell"],
            "current_price": round(self.last_price, 2)
        }
        return features

# global instance
feature_engine = FeatureEngine()


===== live_executor.py =====


# live_executor.py
"""
Live executor for OKX (USDT-Margined Perpetuals).
SAFE BY DEFAULT: DRY_RUN = True.
Use with care. Test in sandbox first.
Requires 'requests'.
"""
import os
import time
import json
import hmac
import base64
import hashlib
import requests
import csv
from datetime import datetime
from decimal import Decimal, ROUND_DOWN

from config import SYMBOL, LOGS_DIR, START_EQUITY, POSITION_PCT

# Env vars: set OKX_API_KEY, OKX_API_SECRET, OKX_API_PASSPHRASE for live mode
API_KEY = os.getenv("OKX_API_KEY", "")
API_SECRET = os.getenv("OKX_API_SECRET", "")
API_PASSPHRASE = os.getenv("OKX_API_PASSPHRASE", "")

# Safety defaults
DRY_RUN = True
MIN_NOTIONAL_USDT = 5.0
OKX_API_BASE = "https://www.okx.com"
OKX_MARKET_TICKER = "/api/v5/market/ticker"
OKX_TRADE_ORDER = "/api/v5/trade/order"
OKX_ACCOUNT_POSITIONS = "/api/v5/account/positions"

LOGFILE = LOGS_DIR / "live_trades.csv"
if not LOGFILE.exists():
    with open(LOGFILE, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["ts","mode","action","side","price","size_contracts","notional_usdt","note","api_response"])

def _now_iso():
    return datetime.utcnow().isoformat() + "Z"

def _sign(timestamp: str, method: str, request_path: str, body: str, secret: str):
    message = timestamp + method.upper() + request_path + (body or "")
    mac = hmac.new(bytes(secret, "utf-8"), bytes(message, "utf-8"), digestmod=hashlib.sha256)
    return base64.b64encode(mac.digest()).decode()

def _request(method: str, path: str, params=None, body: dict=None, timeout=10.0):
    url = OKX_API_BASE + path
    method = method.upper()
    ts = datetime.utcnow().isoformat() + "Z"
    body_str = json.dumps(body) if body else ""
    if API_KEY and API_SECRET and API_PASSPHRASE:
        sign = _sign(ts, method, path, body_str, API_SECRET)
        headers = {
            "OK-ACCESS-KEY": API_KEY,
            "OK-ACCESS-SIGN": sign,
            "OK-ACCESS-TIMESTAMP": ts,
            "OK-ACCESS-PASSPHRASE": API_PASSPHRASE,
            "Content-Type": "application/json"
        }
    else:
        headers = {"Content-Type": "application/json"}

    try:
        if method == "GET":
            r = requests.get(url, params=params, headers=headers, timeout=timeout)
        else:
            r = requests.post(url, params=params, data=body_str, headers=headers, timeout=timeout)
        return r
    except Exception as e:
        return None

def log_row(mode, action, side, price, size_contracts, notional_usdt, note, api_response):
    ts = datetime.utcnow().isoformat()
    with open(LOGFILE, "a", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([ts, mode, action, side, price, size_contracts, notional_usdt, note, json.dumps(api_response)])
    print(f"[{ts}] {mode} {action} {side} price={price} size={size_contracts} notional={notional_usdt} note={note}")

class LiveExecutor:
    def __init__(self, dry_run=True):
        # If API keys are not set, force dry_run
        self.dry_run = dry_run or (API_KEY == "" or API_SECRET == "" or API_PASSPHRASE == "")
        if self.dry_run:
            print("LIVE EXECUTOR: DRY_RUN mode (no real orders).")
        else:
            print("LIVE EXECUTOR: LIVE mode (orders WILL be sent).")
        self.session = requests.Session()

    def get_price(self, instId):
        params = {"instId": instId}
        r = _request("GET", OKX_MARKET_TICKER, params=params)
        if not r or r.status_code != 200:
            return None
        try:
            data = r.json()
            if data.get("code") == "0" and data.get("data"):
                rec = data["data"][0]
                return float(rec.get("last"))
            return None
        except Exception:
            return None

    def _place_market_order(self, instId, side, sz_contracts, tdMode="cross", reduceOnly=False):
        body = {
            "instId": instId,
            "side": side,
            "ordType": "market",
            "sz": str(sz_contracts),
            "tdMode": tdMode
        }
        if reduceOnly:
            body["reduceOnly"] = True

        if self.dry_run:
            resp = {"sim": True, "body": body}
            log_row("DRY", "ORDER", side, None, sz_contracts, None, "simulated_market_order", resp)
            return resp

        r = _request("POST", OKX_TRADE_ORDER, body=body)
        if r is None:
            log_row("ERR", "ORDER", side, None, sz_contracts, None, "http_error", {})
            return None
        try:
            resp = r.json()
        except Exception:
            resp = {"status_code": r.status_code, "text": r.text}
        log_row("LIVE", "ORDER", side, None, sz_contracts, None, "okx_resp", resp)
        return resp

    def enter_position_notional(self, side, notional_usdt):
        notional_usdt = float(notional_usdt)
        if notional_usdt < MIN_NOTIONAL_USDT:
            print("Notional below minimum:", notional_usdt)
            return None

        price = self.get_price(SYMBOL)
        if not price:
            print("Failed to fetch price; abort enter")
            return None

        size = Decimal(notional_usdt / price).quantize(Decimal("0.000001"), rounding=ROUND_DOWN)
        if size <= 0:
            print("Calculated size zero; abort")
            return None

        resp = self._place_market_order(SYMBOL, "buy" if side.upper()=="LONG" else "sell", str(size))
        return {"price": price, "size": float(size), "resp": resp, "notional": notional_usdt}

    def exit_position_market(self):
        if self.dry_run:
            resp = {"sim": True, "note": "simulated_exit"}
            log_row("DRY", "EXIT", "BOTH", None, None, None, "simulated_exit", resp)
            return resp

        # live exit: query positions (user must adapt if OKX returns unexpected structure)
        params = {"instId": SYMBOL}
        r = _request("GET", OKX_ACCOUNT_POSITIONS, params=params)
        if not r or r.status_code != 200:
            print("Failed to query positions")
            return None
        try:
            data = r.json()
        except Exception:
            data = None
        log_row("LIVE", "EXIT", "BOTH", None, None, None, "position_query", data)
        return data

    def safe_enter_from_equity_pct(self, side, pct):
        equity = START_EQUITY
        notional = equity * pct
        return self.enter_position_notional(side, notional)


===== main.py =====


# main.py

import time
from data_collector import DataCollector
from feature_engine import FeatureEngine
from simple_strategy import SimpleStrategy
from live_executor import LiveExecutor
from config import MODE, BUCKET_SECONDS, POSITION_PCT


def run_bot(runtime_seconds=300):
    print(f"Starting Quantum Bot LITE v1.0 (MODE={MODE})")

    # 1. INIT MODULES
    collector = DataCollector()
    collector.start()

    strat = SimpleStrategy()
    executor = LiveExecutor(dry_run=(MODE != "LIVE"))  # If MODE=LIVE → real trading

    fe = FeatureEngine()

    start = time.time()
    last_bucket = 0

    try:
        while True:
            now = time.time()

            # 2. Process data every BUCKET_SECONDS seconds
            if now - last_bucket >= BUCKET_SECONDS:
                snapshot = collector.get_snapshot()
                features = fe.update_from_snapshot(snapshot)
                last_bucket = now

                # Diagnostics
                print("-----", features["timestamp"], "price:", features["current_price"])
                print("imb:", features["order_book_imbalance"],
                      "delta:", features["cumulative_delta"],
                      "spread:", features["spread_percent"])
                
                result = strat.analyze(features)
                print("Strategy:", result)

                # 3. EXECUTION
                if result["action"] == "ENTER":
                    notional_pct = POSITION_PCT / 100 if POSITION_PCT > 1 else POSITION_PCT
                    executor.safe_enter_from_equity_pct(result["side"], notional_pct)

                    strat.record_entry(result["side"], features["current_price"])

                elif result["action"] == "EXIT":
                    executor.exit_position_market()
                    strat.record_exit()

            # 4. Stop by timeout
            if runtime_seconds and (now - start) >= runtime_seconds:
                print("Runtime finished. Stopping bot...")
                break

            time.sleep(0.05)

    except KeyboardInterrupt:
        print("Interrupted manually")

    finally:
        collector.stop()
        print("Collector stopped. Clean exit.")


if __name__ == '__main__':
    run_bot(runtime_seconds=600)


===== simple_strategy.py =====


# simple_strategy.py
import time
from config import IMBALANCE_THRESHOLD, DELTA_THRESHOLD, SPREAD_MAX_PCT, MIN_SIGNAL_INTERVAL, TRADE_HOLD_SECONDS

class SimpleStrategy:
    def __init__(self):
        self.last_trade_time = 0
        self.open_position = None  # {"side","entry_ts","entry_price"}

    def can_trade_now(self):
        return (time.time() - self.last_trade_time) >= MIN_SIGNAL_INTERVAL

    def analyze(self, features):
        imb = features.get("order_book_imbalance", 0.5)
        delta = features.get("cumulative_delta", 0.0)
        spread = features.get("spread_percent", 999.0)
        price = features.get("current_price", 0.0)

        # Reject if spread large or malformed
        if spread <= 0 or spread > SPREAD_MAX_PCT:
            return {"action":"HOLD", "reason":"spread_bad", "confidence":0}

        # If open - check exit
        if self.open_position:
            # time exit
            if time.time() - self.open_position["entry_ts"] >= TRADE_HOLD_SECONDS:
                return {"action":"EXIT", "reason":"time_exit", "side": self.open_position["side"], "price": price}
            # reverse condition
            if self.open_position["side"] == "LONG" and (imb < 0.5 or delta < -DELTA_THRESHOLD):
                return {"action":"EXIT", "reason":"reverse", "side":"LONG", "price": price}
            if self.open_position["side"] == "SHORT" and (imb > 0.5 or delta > DELTA_THRESHOLD):
                return {"action":"EXIT", "reason":"reverse", "side":"SHORT", "price": price}
            return {"action":"HOLD", "reason":"position_open", "confidence":0}

        # No open - entry rules
        if imb > IMBALANCE_THRESHOLD and delta > DELTA_THRESHOLD and self.can_trade_now():
            return {"action":"ENTER", "side":"LONG", "price": price, "confidence":80, "reason":"imb_delta_long"}
        if imb < (1.0 - IMBALANCE_THRESHOLD) and delta < -DELTA_THRESHOLD and self.can_trade_now():
            return {"action":"ENTER", "side":"SHORT", "price": price, "confidence":80, "reason":"imb_delta_short"}

        return {"action":"HOLD", "reason":"no_signal", "confidence":0}

    def record_entry(self, side, price):
        self.open_position = {"side": side, "entry_ts": time.time(), "entry_price": price}
        self.last_trade_time = time.time()

    def record_exit(self):
        self.open_position = None
        self.last_trade_time = time.time()
