

===== config.py =====


# config.py
SYMBOL = "BTC-USDT-SWAP"
BUCKET_SECONDS = 20.0  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 20 —Å–µ–∫—É–Ω–¥ –¥–ª—è M3

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
IMBALANCE_THRESHOLD = 0.7
MIN_VOLUME_ANTI_SPOOFING = 0.5

===== data_collector.py =====


# data_collector.py
import json
import threading
import websocket
import time
from datetime import datetime
from config import SYMBOL

class LiveDataCollector:
    def __init__(self):
        self.price = None
        self.best_bid = None
        self.best_ask = None
        self.spread = None
        self.bids = []
        self.asks = []
        self.trades = []
        
        self.lock = threading.Lock()
        self._ws = None
        self.connected = False

        print("[Collector] Starting OKX WebSocket connection...")
        self._start_ws()

    def _start_ws(self):
        url = "wss://ws.okx.com:8443/ws/v5/public"
        self._ws = websocket.WebSocketApp(
            url,
            on_open=self._on_open,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close
        )

        self.ws_thread = threading.Thread(target=self._ws.run_forever, daemon=True)
        self.ws_thread.start()

    def _on_open(self, ws):
        print("[Collector] ‚úÖ Connected to OKX WebSocket")
        self.connected = True
        
        sub_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "books5", "instId": SYMBOL},
                {"channel": "trades", "instId": SYMBOL}
            ]
        }
        ws.send(json.dumps(sub_msg))
        print("[Collector] ‚úÖ Subscribed to books5 & trades")

    def _on_error(self, ws, error):
        print(f"[Collector] ‚ùå WebSocket error: {error}")
        self.connected = False

    def _on_close(self, ws, close_status_code, close_msg):
        print(f"[Collector] üîå WebSocket closed: {close_status_code} - {close_msg}")
        self.connected = False

    def _on_message(self, ws, message):
        try:
            msg = json.loads(message)
            
            if "event" in msg:
                if msg["event"] == "subscribe":
                    print(f"[Collector] ‚úÖ Subscribed to: {msg.get('arg', {})}")
                return

            if "arg" not in msg:
                return

            channel = msg["arg"]["channel"]

            with self.lock:
                if channel == "books5" and "data" in msg:
                    self._handle_books(msg["data"][0])
                elif channel == "trades" and "data" in msg:
                    self._handle_trades(msg["data"])
                    
        except Exception as e:
            print(f"[Collector] ‚ùå Message processing error: {e}")

    def _handle_books(self, book_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞–∫–∞–Ω"""
        try:
            self.bids = book_data.get("bids", [])
            self.asks = book_data.get("asks", [])
            
            if self.bids and self.asks:
                self.best_bid = float(self.bids[0][0])
                self.best_ask = float(self.asks[0][0])
                self.price = (self.best_bid + self.best_ask) / 2
                self.spread = self.best_ask - self.best_bid
                
        except Exception as e:
            print(f"[Collector] ‚ùå Book processing error: {e}")

    def _handle_trades(self, trades_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–π–¥—ã"""
        try:
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –±–µ—Ä–µ–º –í–°–ï —Ç—Ä–µ–π–¥—ã
            if trades_data:
                self.trades = trades_data
        except Exception as e:
            print(f"[Collector] ‚ùå Trade processing error: {e}")

    def get_snapshot(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Å–Ω–∞–ø—à–æ—Ç –¥–∞–Ω–Ω—ã—Ö"""
        with self.lock:
            return {
                "order_book": {
                    "bids": self.bids,
                    "asks": self.asks,
                    "ts": datetime.utcnow().isoformat()
                },
                "trades": self.trades,
                "price": self.price,
                "spread": self.spread,
                "connected": self.connected
            }

    def stop(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if self._ws:
            self._ws.close()
        self.connected = False

===== feature_engine.py =====


# feature_engine.py
from collections import deque
import time
from datetime import datetime

class FeatureEngine:
    def __init__(self):
        self.last_price = 60000.0
        self.imbalance_history = deque(maxlen=2)
        self.trade_history = deque()
        self.price_history = deque()

    def _calculate_imbalance(self, bids, asks, levels=3):
        """–†–∞—Å—á–µ—Ç –∏–º–±–∞–ª–∞–Ω—Å–∞"""
        levels = min(len(bids), len(asks), levels)
        if levels == 0:
            return 0.5
            
        bid_vol = sum(float(bid[1]) for bid in bids[:levels])
        ask_vol = sum(float(ask[1]) for ask in asks[:levels])
        total = bid_vol + ask_vol
        
        return bid_vol / total if total > 0 else 0.5

    def update_trades(self, trades):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–µ–π–¥–æ–≤"""
        ts = time.time()
        for trade in trades:
            side = trade.get("side", "buy")
            volume = float(trade.get("sz", 0))
            self.trade_history.append((ts, side, volume))
        self.price_history.append((ts, self.last_price))

    def compute_delta_absorption(self, window=10):  # 10 —Å–µ–∫—É–Ω–¥ –¥–ª—è M3
        """–°—á–∏—Ç–∞–µ–º –¥–µ–ª—å—Ç—É –∏ absorption"""
        now = time.time()
        while self.trade_history and self.trade_history[0][0] < now - window:
            self.trade_history.popleft()
        while self.price_history and self.price_history[0][0] < now - window:
            self.price_history.popleft()

        delta = sum(v for t,s,v in self.trade_history if s=="buy") - sum(v for t,s,v in self.trade_history if s=="sell")
        price_change = self.last_price - self.price_history[0][1] if self.price_history else 0

        absorption_up = price_change > 0 and delta <= 0
        absorption_down = price_change < 0 and delta >= 0

        return {
            "delta": delta,
            "price_change": price_change,
            "absorption_up": absorption_up,
            "absorption_down": absorption_down
        }

    def update_from_snapshot(self, snapshot):
        current_time = time.time()
        ob = snapshot.get("order_book", {})
        trades = snapshot.get("trades", [])

        bids = ob.get("bids", [])
        asks = ob.get("asks", [])
        if bids and asks:
            try:
                best_bid = float(bids[0][0])
                best_ask = float(asks[0][0])
                if best_ask > best_bid:
                    self.last_price = (best_bid + best_ask) / 2
            except (ValueError, IndexError):
                pass

        current_imbalance = 0.5
        if bids and asks:
            current_imbalance = self._calculate_imbalance(bids, asks)
            self.imbalance_history.append(current_imbalance)

        if len(self.imbalance_history) >= 2:
            trend = "rising" if current_imbalance > self.imbalance_history[-2] else "falling"
        else:
            trend = "flat"

        self.update_trades(trades)
        abs_features = self.compute_delta_absorption(window=10)  # 10 —Å–µ–∫—É–Ω–¥ –¥–ª—è M3

        return {
            "timestamp": datetime.utcnow().isoformat(),
            "order_book_imbalance": round(current_imbalance, 4),
            "imbalance_trend": trend,
            "current_price": round(self.last_price, 2),
            **abs_features
        }

feature_engine = FeatureEngine()

===== main.py =====


# main.py
import time
from data_collector import LiveDataCollector
from feature_engine import feature_engine
from simple_strategy import SimpleStrategy
from telegram_notifier import telegram
from config import BUCKET_SECONDS

def run_bot():
    print("Bot starting...")
    telegram.send_bot_status("start")

    collector = LiveDataCollector()
    strat = SimpleStrategy()

    time.sleep(5)
    print("Bot is running...")

    try:
        while True:
            snapshot = collector.get_snapshot()
            if not snapshot.get("connected", False):
                print("WebSocket not connected")
                time.sleep(1)
                continue

            features = feature_engine.update_from_snapshot(snapshot)
            
            # –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –≤—ã–≤–æ–¥ –¥–ª—è M3 —Ç–µ—Å—Ç–∞
            print(f"Price: {features['current_price']}")
            print(f"Delta: {features['delta']:.1f}")
            print(f"Abs UP: {features['absorption_up']}, DOWN: {features['absorption_down']}")
            print("---")

            result = strat.analyze(features)

            if result["action"] == "ENTER":
                side = result["side"]
                price = result["price"]
                strat.record_entry(side, price)
                telegram.send_trade_signal(side, price)
                print(f"SIGNAL: {side} {price:.2f} | {result['reason']}")
            else:
                print(f"HOLD | {result['reason']}")
            print("---")

            time.sleep(BUCKET_SECONDS)

    except KeyboardInterrupt:
        print("Bot stopped")
        telegram.send_bot_status("stop")

if __name__ == "__main__":
    run_bot()

===== simple_strategy.py =====


# simple_strategy.py
import time

class SimpleStrategy:
    def __init__(self):
        self.open_position = None

    def analyze(self, features):
        price = features.get("current_price", 0.0)
        delta = features.get("delta", 0)
        abs_up = features.get("absorption_up", False)
        abs_down = features.get("absorption_down", False)

        # LONG —Å–∏–≥–Ω–∞–ª - –±–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–ª—è M3
        if delta < -0.5 or abs_down:  # –±—ã–ª–æ -1.0
            return {
                "action": "ENTER",
                "side": "LONG",
                "price": price,
                "reason": f"absorption_down / delta {delta:.1f}"
            }

        # SHORT —Å–∏–≥–Ω–∞–ª - –±–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–ª—è M3
        if delta > 0.5 or abs_up:  # –±—ã–ª–æ 1.0
            return {
                "action": "ENTER",
                "side": "SHORT",
                "price": price,
                "reason": f"absorption_up / delta {delta:.1f}"
            }

        return {"action": "HOLD", "reason": f"no signal delta {delta:.1f}"}

    def record_entry(self, side, price):
        self.open_position = {
            "side": side,
            "entry_price": price,
            "entry_ts": time.time()
        }

===== telegram_notifier.py =====


# telegram_notifier.py
import requests
import os
from dotenv import load_dotenv

load_dotenv()  # –ó–ê–ì–†–£–ñ–ê–ï–ú –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò–ó .env

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")

class TelegramNotifier:
    def __init__(self):
        self.enabled = bool(TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID)
        print(f"[Telegram] Enabled: {self.enabled}")
        if self.enabled:
            print(f"[Telegram] Token: {TELEGRAM_BOT_TOKEN[:10]}...")
            print(f"[Telegram] Chat ID: {TELEGRAM_CHAT_ID}")

    def _send_message(self, message):
        if not self.enabled:
            return
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            payload = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
            response = requests.post(url, json=payload, timeout=5)
            print(f"[Telegram] Sent: {message}")
        except Exception as e:
            print(f"[Telegram] Error: {e}")

    def send_bot_status(self, status):
        self._send_message(status)

    def send_trade_signal(self, side, price):
        self._send_message(f"{side.lower()} {price:.2f}")

telegram = TelegramNotifier()
