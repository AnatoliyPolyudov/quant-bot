

===== baseline_strategy.py =====


# baseline_strategy.py
import numpy as np
from datetime import datetime
from config import config  # üîß –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–£–Æ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ

class BaselineStrategy:
    def __init__(self):
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ –°–¢–†–ê–¢–ï–ì–ò–ò
        self.min_imbalance = config.strategy.BASELINE_MIN_IMBALANCE
        self.min_delta = config.strategy.BASELINE_MIN_DELTA
        self.max_spread = config.strategy.BASELINE_MAX_SPREAD
        self.max_volatility = config.strategy.BASELINE_MAX_VOLATILITY
        self.min_confidence = config.strategy.BASELINE_MIN_CONFIDENCE
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –í–ï–°–ê –ò–ó –ö–û–ù–§–ò–ì–ê
        self.feature_weights = config.strategy.FEATURE_WEIGHTS
        
        # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.recent_signals = []
        self.market_regime = "NORMAL"
        self.last_regime_update = 0
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–ê–†–ê–ú–ï–¢–†–´ –†–´–ù–û–ß–ù–´–• –†–ï–ñ–ò–ú–û–í –ò–ó –ö–û–ù–§–ò–ì–ê
        self.market_regime_params = {
            "VOLATILE": config.strategy.VOLATILE_MARKET_PARAMS,
            "TRENDING": config.strategy.TRENDING_MARKET_PARAMS,
            "NORMAL": config.strategy.NORMAL_MARKET_PARAMS
        }
        
    def update_market_regime(self, features):
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º"""
        current_time = datetime.now().timestamp()
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∂–∏–º –Ω–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ 30 —Å–µ–∫—É–Ω–¥
        if current_time - self.last_regime_update < 30:
            return
            
        self.last_regime_update = current_time
        volatility = features.get('volatility', 0)
        imbalance = features.get('order_book_imbalance', 0.5)
        
        if volatility > 1.5:
            self.market_regime = "VOLATILE"
        elif abs(imbalance - 0.5) > 0.3:
            self.market_regime = "TRENDING" 
        else:
            self.market_regime = "NORMAL"
            
        # üîß –ê–î–ê–ü–¢–ò–†–£–ï–ú –ü–ê–†–ê–ú–ï–¢–†–´ –ü–û–î –†–ï–ñ–ò–ú –ò–ó –ö–û–ù–§–ò–ì–ê
        regime_params = self.market_regime_params.get(self.market_regime, {})
        self.min_imbalance = regime_params.get('min_imbalance', self.min_imbalance)
        self.min_delta = regime_params.get('min_delta', self.min_delta)
        self.max_volatility = regime_params.get('max_volatility', self.max_volatility)
    
    def calculate_composite_score(self, features):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–º–ø–æ–∑–∏—Ç–Ω—ã–π —Å–∫–æ—Ä–∏–Ω–≥ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Å–µ—Ö —Ñ–∏—á"""
        imbalance = features.get('order_book_imbalance', 0.5)
        delta = features.get('cumulative_delta', 0)
        spread = features.get('spread_percent', 0)
        volatility = features.get('volatility', 0)
        funding = features.get('funding_rate', 0)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ñ–∏—á–∏ –¥–ª—è —Å–∫–æ—Ä–∏–Ω–≥–∞
        imbalance_score = max(0, (imbalance - 0.5) / 0.5)  # -1 to 1
        delta_score = np.tanh(delta / 10)  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–µ–ª—å—Ç—É
        spread_score = max(0, 1 - (spread / self.max_spread))  # 0 to 1
        volatility_score = max(0, 1 - (volatility / self.max_volatility))  # 0 to 1
        funding_score = -np.tanh(funding * 1000)  # –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π funding = —Ö–æ—Ä–æ—à–æ
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –í–ó–í–ï–®–ï–ù–ù–£–Æ –°–£–ú–ú–£ –ò–ó –ö–û–ù–§–ò–ì–ê
        composite = (
            imbalance_score * self.feature_weights['imbalance'] +
            delta_score * self.feature_weights['delta'] +
            spread_score * self.feature_weights['spread'] +
            volatility_score * self.feature_weights['volatility'] +
            funding_score * self.feature_weights['funding']
        )
        
        return composite, {
            'imbalance_score': imbalance_score,
            'delta_score': delta_score, 
            'spread_score': spread_score,
            'volatility_score': volatility_score,
            'funding_score': funding_score
        }
    
    def analyze_momentum(self, features):
        """–ê–Ω–∞–ª–∏–∑ –º–æ–º–µ–Ω—Ç–∞um –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
        imbalance = features.get('order_book_imbalance', 0.5)
        delta = features.get('cumulative_delta', 0)
        
        momentum_score = 0
        momentum_signals = []
        
        # –°–∏–ª—å–Ω—ã–π imbalance
        if imbalance > 0.65:
            momentum_score += 2
            momentum_signals.append("üí™ –°–∏–ª—å–Ω—ã–π imbalance")
        elif imbalance > 0.6:
            momentum_score += 1
            momentum_signals.append("üìä imbalance –≤ –ø–æ–ª—å–∑—É buyers")
            
        # –°–∏–ª—å–Ω–∞—è –¥–µ–ª—å—Ç–∞
        if delta > 5:
            momentum_score += 2
            momentum_signals.append("üöÄ –°–∏–ª—å–Ω—ã–π inflow")
        elif delta > 2:
            momentum_score += 1
            momentum_signals.append("üìà –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è –¥–µ–ª—å—Ç–∞")
            
        # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª
        if imbalance > 0.6 and delta > 3:
            momentum_score += 1
            momentum_signals.append("üéØ –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª")
            
        return momentum_score, momentum_signals
    
    def analyze_signal(self, features):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –∫–æ–º–ø–æ–∑–∏—Ç–Ω—ã–º —Å–∫–æ—Ä–∏–Ω–≥–æ–º"""
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º
        self.update_market_regime(features)
        
        imbalance = features.get('order_book_imbalance', 0.5)
        delta = features.get('cumulative_delta', 0)
        spread = features.get('spread_percent', 0)
        funding = features.get('funding_rate', 0)
        volatility = features.get('volatility', 0)
        
        signals = []
        warning_signals = []
        
        # –ö–æ–º–ø–æ–∑–∏—Ç–Ω—ã–π —Å–∫–æ—Ä–∏–Ω–≥
        composite_score, score_details = self.calculate_composite_score(features)
        momentum_score, momentum_signals = self.analyze_momentum(features)
        
        # üîß –£–õ–£–ß–®–ï–ù–ù–´–ï –ü–†–ê–í–ò–õ–ê –° –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï–ú –ö–û–ù–§–ò–ì–ê
        
        # –ü—Ä–∞–≤–∏–ª–æ 1: Imbalance —Å –≥—Ä–∞–¥–∞—Ü–∏–µ–π
        if imbalance > 0.65:
            signals.append("üí™ –°–ò–õ–¨–ù–´–ô Imbalance {:.3f} > 0.65".format(imbalance))
        elif imbalance > self.min_imbalance:
            signals.append("üìä Imbalance {:.3f} > {}".format(imbalance, self.min_imbalance))
        elif imbalance < 0.35:
            signals.append("üí™ –°–ò–õ–¨–ù–´–ô Short Imbalance {:.3f} < 0.35".format(imbalance))
        elif imbalance < (1 - self.min_imbalance):
            signals.append("üìä Short Imbalance {:.3f} < {}".format(imbalance, 1 - self.min_imbalance))
        
        # –ü—Ä–∞–≤–∏–ª–æ 2: Delta —Å –≥—Ä–∞–¥–∞—Ü–∏–µ–π
        if delta > 5:
            signals.append("üöÄ –°–ò–õ–¨–ù–´–ô Delta {:.1f} > 5".format(delta))
        elif delta > self.min_delta:
            signals.append("üìà Delta {:.1f} > {}".format(delta, self.min_delta))
        elif delta < -5:
            signals.append("üöÄ –°–ò–õ–¨–ù–´–ô Short Delta {:.1f} < -5".format(delta))
        elif delta < -self.min_delta:
            signals.append("üìà Short Delta {:.1f} < -{}".format(delta, self.min_delta))
        
        # –ü—Ä–∞–≤–∏–ª–æ 3: Spread
        if spread < self.max_spread:
            signals.append("üìè Spread {:.4f}% < {}%".format(spread, self.max_spread))
        else:
            warning_signals.append("‚ùå Spread {:.4f}% —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫".format(spread))
        
        # –ü—Ä–∞–≤–∏–ª–æ 4: –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
        if volatility < self.max_volatility:
            signals.append("üìä Volatility {:.3f}% < {}%".format(volatility, self.max_volatility))
        else:
            warning_signals.append("‚ö° Volatility {:.3f}% —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–∞".format(volatility))
        
        # –ü—Ä–∞–≤–∏–ª–æ 5: Funding
        if abs(funding) < 0.0001:
            signals.append("üí∞ Funding –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π")
        elif funding > 0.0005:
            warning_signals.append("üî¥ Positive funding {:.6f} (SHORT bias)".format(funding))
        elif funding < -0.0005:
            signals.append("üü¢ Negative funding {:.6f} (LONG bias)".format(funding))
        else:
            signals.append("üí∞ Funding {:.6f}".format(funding))
        
        # –î–æ–±–∞–≤–ª—è–µ–º momentum —Å–∏–≥–Ω–∞–ª—ã
        signals.extend(momentum_signals)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä—ã–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ
        signals.append("üé™ –†–µ–∂–∏–º: {}".format(self.market_regime))
        
        # üîß –£–õ–£–ß–®–ï–ù–ù–û–ï –ü–†–ò–ù–Ø–¢–ò–ï –†–ï–®–ï–ù–ò–ô –° –ö–û–ù–§–ò–ì–û–ú
        base_buy_signal = (imbalance > self.min_imbalance and 
                          delta > self.min_delta and 
                          spread < self.max_spread and
                          volatility < self.max_volatility)
        
        base_sell_signal = (imbalance < (1 - self.min_imbalance) and 
                           delta < -self.min_delta and 
                           spread < self.max_spread and
                           volatility < self.max_volatility)
        
        # –£—Å–∏–ª–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        strong_buy_signal = (imbalance > 0.65 or delta > 5) and base_buy_signal
        strong_sell_signal = (imbalance < 0.35 or delta < -5) and base_sell_signal
        
        # –ö–æ–º–ø–æ–∑–∏—Ç–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
        if composite_score > 0.1 and base_buy_signal:
            decision = "LONG"
            confidence = self.calculate_confidence(composite_score, momentum_score, features, warning_signals)
        elif composite_score < -0.1 and base_sell_signal:
            decision = "SHORT"
            confidence = self.calculate_confidence(-composite_score, momentum_score, features, warning_signals)
        else:
            decision = "HOLD"
            confidence = 0
        
        # –£—Å–∏–ª–∏–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è —Å–∏–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        if strong_buy_signal and decision == "LONG":
            confidence = min(95, confidence + 15)
            signals.append("üí™ –£–°–ò–õ–ï–ù–ù–´–ô LONG —Å–∏–≥–Ω–∞–ª")
        elif strong_sell_signal and decision == "SHORT":
            confidence = min(95, confidence + 15)
            signals.append("üí™ –£–°–ò–õ–ï–ù–ù–´–ô SHORT —Å–∏–≥–Ω–∞–ª")
        
        # –£—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
        if warning_signals:
            confidence = max(0, confidence - len(warning_signals) * 10)
            signals.extend(warning_signals)
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ú–ò–ù–ò–ú–ê–õ–¨–ù–£–Æ –£–í–ï–†–ï–ù–ù–û–°–¢–¨ –ò–ó –ö–û–ù–§–ò–ì–ê
        if confidence < self.min_confidence and decision != "HOLD":
            decision = "HOLD"
            confidence = 0
            signals.append("üéØ –°–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è —Å–¥–µ–ª–∫–∏")
        
        return {
            'decision': decision,
            'confidence': confidence,
            'signals': signals,
            'composite_score': composite_score,
            'momentum_score': momentum_score,
            'imbalance': imbalance,
            'delta': delta,
            'spread': spread,
            'volatility': volatility,
            'market_regime': self.market_regime,
            'feature_scores': score_details
        }
    
    def calculate_confidence(self, composite_score, momentum_score, features, warning_signals):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏"""
        base_confidence = composite_score * 100
        
        # –ë–æ–Ω—É—Å –∑–∞ momentum
        momentum_bonus = momentum_score * 8
        
        # –®—Ç—Ä–∞—Ñ –∑–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
        volatility = features.get('volatility', 0)
        vol_penalty = max(0, (volatility / self.max_volatility) * 20)
        
        # –®—Ç—Ä–∞—Ñ –∑–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
        warning_penalty = len(warning_signals) * 12
        
        confidence = base_confidence + momentum_bonus - vol_penalty - warning_penalty
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
        confidence = max(0, min(95, confidence))
        
        return confidence

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
baseline_strategy = BaselineStrategy()


===== config.py =====


# config.py
from dataclasses import dataclass
from typing import List, Dict, Any
import os
from datetime import timedelta

@dataclass
class DataConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
    # WebSocket –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    WS_URL: str = "wss://ws.okx.com:8443/ws/v5/public"
    RECONNECT_ATTEMPTS: int = 10
    RECONNECT_DELAY: int = 5  # —Å–µ–∫—É–Ω–¥
    
    # –ö–∞–Ω–∞–ª—ã –¥–∞–Ω–Ω—ã—Ö
    CHANNELS: List[str] = None
    
    # –°–∏–º–≤–æ–ª—ã –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏
    SYMBOL: str = "BTC-USDT-SWAP"
    SYMBOLS: List[str] = None
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏—á
    FEATURE_WINDOW: int = 50
    VOLATILITY_WINDOW: int = 30
    TARGET_HORIZON: int = 8  # —Å–µ–∫—É–Ω–¥ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ target
    TARGET_THRESHOLD: float = 0.01  # 0.01% –ø–æ—Ä–æ–≥ –¥–ª—è target
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    LOG_INTERVAL: int = 5  # —Å–µ–∫—É–Ω–¥ –º–µ–∂–¥—É –∑–∞–ø–∏—Å—è–º–∏
    MAX_RECORDS: int = 10000  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –≤ —Ñ–∞–π–ª–µ
    
    def __post_init__(self):
        if self.CHANNELS is None:
            self.CHANNELS = ["books", "trades", "tickers"]
        if self.SYMBOLS is None:
            self.SYMBOLS = [self.SYMBOL]

@dataclass
class StrategyConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π"""
    
    # Baseline —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
    BASELINE_MIN_IMBALANCE: float = 0.58
    BASELINE_MIN_DELTA: float = 2
    BASELINE_MAX_SPREAD: float = 0.025
    BASELINE_MAX_VOLATILITY: float = 0.8
    BASELINE_MIN_CONFIDENCE: int = 60
    
    # –í–µ—Å–∞ —Ñ–∏—á –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ç–Ω–æ–≥–æ —Å–∫–æ—Ä–∏–Ω–≥–∞
    FEATURE_WEIGHTS: Dict[str, float] = None
    
    # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä—ã–Ω–æ—á–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
    VOLATILE_MARKET_PARAMS: Dict[str, Any] = None
    TRENDING_MARKET_PARAMS: Dict[str, Any] = None
    NORMAL_MARKET_PARAMS: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.FEATURE_WEIGHTS is None:
            self.FEATURE_WEIGHTS = {
                'imbalance': 0.35,
                'delta': 0.25,
                'spread': 0.15,
                'volatility': 0.15,
                'funding': 0.10
            }
        
        if self.VOLATILE_MARKET_PARAMS is None:
            self.VOLATILE_MARKET_PARAMS = {
                'min_imbalance': 0.62,
                'min_delta': 3,
                'max_volatility': 0.6
            }
        
        if self.TRENDING_MARKET_PARAMS is None:
            self.TRENDING_MARKET_PARAMS = {
                'min_imbalance': 0.56,
                'min_delta': 1,
                'max_volatility': 1.0
            }
        
        if self.NORMAL_MARKET_PARAMS is None:
            self.NORMAL_MARKET_PARAMS = {
                'min_imbalance': 0.58,
                'min_delta': 2,
                'max_volatility': 0.8
            }

@dataclass
class ModelConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ML –º–æ–¥–µ–ª–∏"""
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±—É—á–µ–Ω–∏—è
    MODEL_TYPE: str = "RandomForest"
    MODEL_PATH: str = "models/quant_model.pkl"
    METADATA_PATH: str = "models/model_metadata.pkl"
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
    RANDOM_FOREST_PARAMS: Dict[str, Any] = None
    MIN_TRAINING_RECORDS: int = 30
    TEST_SIZE: float = 0.2
    CROSS_VALIDATION_SPLITS: int = 5
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –º–æ–¥–µ–ª–∏
    FEATURE_COLUMNS: List[str] = None
    
    # –ü–æ—Ä–æ–≥–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
    MIN_PROBABILITY: float = 0.65
    CONFIDENCE_THRESHOLD: float = 0.7
    
    def __post_init__(self):
        if self.RANDOM_FOREST_PARAMS is None:
            self.RANDOM_FOREST_PARAMS = {
                'n_estimators': 100,
                'max_depth': 10,
                'min_samples_split': 5,
                'random_state': 42
            }
        
        if self.FEATURE_COLUMNS is None:
            self.FEATURE_COLUMNS = [
                'order_book_imbalance',
                'spread_percent',
                'cumulative_delta',
                'funding_rate',
                'buy_trades',
                'sell_trades',
                'total_trades',
                'volatility'
            ]

@dataclass
class TradingConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏"""
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    ENABLED: bool = False  # üîß –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    MODE: str = "paper"  # paper, live
    INITIAL_BALANCE: float = 1000.0
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∑–∏—Ü–∏–∏
    POSITION_SIZE: float = 0.1  # 10% –æ—Ç –±–∞–ª–∞–Ω—Å–∞
    MAX_POSITION_SIZE: float = 0.3  # 30% –º–∞–∫—Å–∏–º—É–º
    LEVERAGE: int = 3
    
    # –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
    STOP_LOSS_PERCENT: float = 2.0  # 2% —Å—Ç–æ–ø-–ª–æ—Å—Å
    TAKE_PROFIT_PERCENT: float = 3.0  # 3% —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç
    MAX_DRAWDOWN: float = 10.0  # 10% –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞
    
    # –¢–æ—Ä–≥–æ–≤—ã–µ —á–∞—Å—ã
    TRADING_HOURS_START: str = "00:00"
    TRADING_HOURS_END: str = "23:59"
    
    # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
    CONFIDENCE_MULTIPLIERS: Dict[str, float] = None
    
    def __post_init__(self):
        if self.CONFIDENCE_MULTIPLIERS is None:
            self.CONFIDENCE_MULTIPLIERS = {
                'high_confidence': 1.0,  # 80-100%
                'medium_confidence': 0.5,  # 60-80%
                'low_confidence': 0.2  # <60%
            }

@dataclass
class MonitoringConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    
    # –ò–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø—Ä–æ–≤–µ—Ä–æ–∫
    HEALTH_CHECK_INTERVAL: int = 60  # —Å–µ–∫—É–Ω–¥
    PROGRESS_CHECK_INTERVAL: int = 120  # —Å–µ–∫—É–Ω–¥
    DATA_QUALITY_CHECK_INTERVAL: int = 300  # —Å–µ–∫—É–Ω–¥
    
    # –ü–æ—Ä–æ–≥–∏ –¥–ª—è –æ–ø–æ–≤–µ—â–µ–Ω–∏–π
    DATA_QUALITY_THRESHOLD: int = 50  # –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–ª –∫–∞—á–µ—Å—Ç–≤–∞
    CONNECTION_QUALITY_THRESHOLD: str = "POOR"  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
    MIN_ACTIVE_RECORDS: int = 10  # –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –≤ –º–∏–Ω—É—Ç—É
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç—á–µ—Ç–æ–≤
    ENABLE_DETAILED_REPORTS: bool = True
    SAVE_STATS_TO_FILE: bool = True
    STATS_FILE: str = "data/system_stats.json"

@dataclass
class LoggingConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
    
    # –£—Ä–æ–≤–Ω–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    CONSOLE_LEVEL: str = "INFO"  # DEBUG, INFO, WARNING, ERROR
    FILE_LEVEL: str = "DEBUG"
    
    # –§–∞–π–ª—ã –ª–æ–≥–æ–≤
    LOG_DIR: str = "logs"
    MAIN_LOG_FILE: str = "quantum_bot.log"
    ERROR_LOG_FILE: str = "errors.log"
    DATA_LOG_FILE: str = "data_log.csv"
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–æ—Ä–º–∞—Ç–∞
    LOG_FORMAT: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    DATE_FORMAT: str = "%Y-%m-%d %H:%M:%S"
    
    # –†–æ—Ç–∞—Ü–∏—è –ª–æ–≥–æ–≤
    MAX_LOG_SIZE: int = 10 * 1024 * 1024  # 10 MB
    BACKUP_COUNT: int = 5
    
    def __post_init__(self):
        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤
        os.makedirs(self.LOG_DIR, exist_ok=True)

@dataclass
class QuantumConfig:
    """–ì–ª–∞–≤–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Quantum Trading Bot"""
    
    # –í–µ—Ä—Å–∏—è –∏ —Ä–µ–∂–∏–º
    VERSION: str = "2.0.0"
    ENVIRONMENT: str = "development"  # development, testing, production
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    data: DataConfig = None
    strategy: StrategyConfig = None
    model: ModelConfig = None
    trading: TradingConfig = None
    monitoring: MonitoringConfig = None
    logging: LoggingConfig = None
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    DEBUG_MODE: bool = True
    DRY_RUN: bool = True  # –†–µ–∂–∏–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑ —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
    
    def __post_init__(self):
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–¥–∫–æ–Ω—Ñ–∏–≥–∏ –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã
        if self.data is None:
            self.data = DataConfig()
        if self.strategy is None:
            self.strategy = StrategyConfig()
        if self.model is None:
            self.model = ModelConfig()
        if self.trading is None:
            self.trading = TradingConfig()
        if self.monitoring is None:
            self.monitoring = MonitoringConfig()
        if self.logging is None:
            self.logging = LoggingConfig()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = QuantumConfig()

# üîß Backward compatibility - —Å—Ç–∞—Ä—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
SYMBOL = config.data.SYMBOL
TIMEFRAME = "1m"  # –û—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
WS_URL = config.data.WS_URL
CHANNELS = config.data.CHANNELS
FEATURE_WINDOW = config.data.FEATURE_WINDOW
MIN_PROBABILITY = config.model.MIN_PROBABILITY

def update_config_from_env():
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
    import os
    
    # –î–∞–Ω–Ω—ã–µ
    if os.getenv('QUANTUM_SYMBOL'):
        config.data.SYMBOL = os.getenv('QUANTUM_SYMBOL')
    if os.getenv('QUANTUM_WS_URL'):
        config.data.WS_URL = os.getenv('QUANTUM_WS_URL')
    
    # –¢–æ—Ä–≥–æ–≤–ª—è
    if os.getenv('QUANTUM_TRADING_ENABLED'):
        config.trading.ENABLED = os.getenv('QUANTUM_TRADING_ENABLED').lower() == 'true'
    if os.getenv('QUANTUM_TRADING_MODE'):
        config.trading.MODE = os.getenv('QUANTUM_TRADING_MODE')
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    if os.getenv('QUANTUM_DEBUG'):
        config.DEBUG_MODE = os.getenv('QUANTUM_DEBUG').lower() == 'true'
    
    print("üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

def save_config_to_file(filename: str = "config/quantum_config.json"):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤ —Ñ–∞–π–ª"""
    import json
    
    os.makedirs("config", exist_ok=True)
    
    config_dict = {
        'version': config.VERSION,
        'environment': config.ENVIRONMENT,
        'data': config.data.__dict__,
        'strategy': config.strategy.__dict__,
        'model': config.model.__dict__,
        'trading': config.trading.__dict__,
        'monitoring': config.monitoring.__dict__,
        'logging': config.logging.__dict__,
        'debug_mode': config.DEBUG_MODE,
        'dry_run': config.DRY_RUN
    }
    
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(config_dict, f, indent=2, ensure_ascii=False)
    
    print(f"üíæ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

def load_config_from_file(filename: str = "config/quantum_config.json"):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ —Ñ–∞–π–ª–∞"""
    import json
    
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            config_dict = json.load(f)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        if 'data' in config_dict:
            for key, value in config_dict['data'].items():
                if hasattr(config.data, key):
                    setattr(config.data, key, value)
        
        print(f"üìÅ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {filename}")
        return True
        
    except FileNotFoundError:
        print(f"üìÅ –§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {filename}")
        return False
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
        return False

# üîß –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ
if load_config_from_file():
    print("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ —Ñ–∞–π–ª–∞")
else:
    # –°–æ–∑–¥–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    save_config_to_file()
    print("‚úÖ –°–æ–∑–¥–∞–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")

# –û–±–Ω–æ–≤–ª—è–µ–º –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
update_config_from_env()


===== data_collector.py =====


# data_collector.py
import websocket
import json
import threading
import time
from datetime import datetime
import ssl
from feature_engine import feature_engine
from data_logger import data_logger
from baseline_strategy import baseline_strategy
from config import config  # üîß –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–£–Æ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ

class OKXDataCollector:
    def __init__(self):
        self.ws = None
        self.data_buffer = []
        self.message_count = 0
        self.last_feature_print = 0
        self.last_data_log = 0
        self.connection_start_time = 0
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = config.data.RECONNECT_ATTEMPTS  # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì
        
        # –†–∞–∑–¥–µ–ª—å–Ω—ã–µ –±—É—Ñ–µ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
        self.order_book_data = []
        self.trade_data = []
        self.ticker_data = []
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
        self.stats = {
            'messages_received': 0,
            'features_processed': 0,
            'last_successful_update': 0,
            'connection_quality': 'UNKNOWN',
            'data_quality_issues': 0
        }
        
        # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ —Ç–∏–ø–∞–º –¥–∞–Ω–Ω—ã—Ö
        self.last_update_time = {
            'order_book': 0,
            'trades': 0,
            'ticker': 0
        }
        
    def on_message(self, ws, message):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            data = json.loads(message)
            self.message_count += 1
            self.stats['messages_received'] += 1
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã—Ö 2 —Å–æ–æ–±—â–µ–Ω–∏–π –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
            if self.message_count <= 2:
                print(f"\nüîç RAW MESSAGE #{self.message_count}:")
                print(f"   Keys: {list(data.keys())}")
                if 'arg' in data:
                    print(f"   Channel: {data['arg']}")
                if 'data' in data:
                    print(f"   Data length: {len(data['data'])}")
                    if len(data['data']) > 0:
                        print(f"   First item keys: {list(data['data'][0].keys())}")
                        sample = str(data['data'][0])[:150]
                        print(f"   Sample: {sample}...")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
            if 'event' in data:
                if data['event'] != 'subscribe':  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏
                    print(f"‚ö° Event: {data['event']} - {data.get('msg', '')}")
            elif 'data' in data:
                channel = data.get('arg', {}).get('channel', 'unknown')
                current_time = time.time()
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –±—É—Ñ–µ—Ä—ã
                if channel == 'books':
                    self.order_book_data = data['data']
                    self.last_update_time['order_book'] = current_time
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å—Ç–∞–∫–∞–Ω–∞
                    if self.message_count <= 2 and len(data['data']) > 0:
                        book = data['data'][0]
                        bids_count = len(book.get('bids', []))
                        asks_count = len(book.get('asks', []))
                        print(f"   üìö Order Book - Bids: {bids_count}, Asks: {asks_count}")
                        
                elif channel == 'trades':
                    self.trade_data = data['data']
                    self.last_update_time['trades'] = current_time
                    
                    if self.message_count <= 2 and len(data['data']) > 0:
                        trade = data['data'][0]
                        print(f"   üí∞ Trade - Side: {trade.get('side')}, Size: {trade.get('sz')}, Price: {trade.get('px')}")
                        
                elif channel == 'tickers':
                    self.ticker_data = data['data']
                    self.last_update_time['ticker'] = current_time
                    
                    if self.message_count <= 2 and len(data['data']) > 0:
                        ticker = data['data'][0]
                        print(f"   üìà Ticker - Last: {ticker.get('last')}, Funding: {ticker.get('fundingRate')}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
                if self.is_data_quality_good():
                    self.update_features()
                else:
                    self.stats['data_quality_issues'] += 1
                    if self.stats['data_quality_issues'] % 10 == 0:
                        print(f"‚ö†Ô∏è  –ü—Ä–æ–±–ª–µ–º—ã —Å –∫–∞—á–µ—Å—Ç–≤–æ–º –¥–∞–Ω–Ω—ã—Ö: {self.stats['data_quality_issues']}")
                
        except Exception as e:
            print(f"‚ùå Message error: {e}")
            self.stats['data_quality_issues'] += 1
    
    def is_data_quality_good(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        try:
            current_time = time.time()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
            has_order_book = len(self.order_book_data) > 0
            has_trades = len(self.trade_data) > 0  
            has_ticker = len(self.ticker_data) > 0
            
            if not (has_order_book and has_trades and has_ticker):
                return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö (–Ω–µ —Å—Ç–∞—Ä—à–µ 10 —Å–µ–∫—É–Ω–¥)
            max_age = 10
            for data_type, last_update in self.last_update_time.items():
                if current_time - last_update > max_age:
                    return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞–∫–∞–Ω –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
            if has_order_book:
                book = self.order_book_data[0]
                bids = book.get('bids', [])
                asks = book.get('asks', [])
                
                if len(bids) == 0 or len(asks) == 0:
                    return False
                    
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ü–µ–Ω—ã –≤ —Å—Ç–∞–∫–∞–Ω–µ –≤–∞–ª–∏–¥–Ω—ã
                best_bid = float(bids[0][0]) if len(bids[0]) > 0 else 0
                best_ask = float(asks[0][0]) if len(asks[0]) > 0 else 0
                
                if best_bid <= 0 or best_ask <= 0 or best_bid >= best_ask:
                    return False
            
            return True
            
        except Exception as e:
            return False
    
    def update_features(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ñ–∏—á–∏ –∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤—ã–≤–æ–¥–æ–º/–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        current_time = time.time()
        
        # –í—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏—á–∏
        features = feature_engine.get_all_features(
            self.order_book_data, 
            self.trade_data, 
            self.ticker_data
        )
        
        # –ê–Ω–∞–ª–∏–∑ –±–µ–π–∑–ª–∞–π–Ω-—Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
        strategy_result = baseline_strategy.analyze_signal(features)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
        data_logger.log_features(features)
        
        self.stats['features_processed'] += 1
        self.stats['last_successful_update'] = current_time
        
        # –í—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
        if current_time - self.last_feature_print > 15:
            self.last_feature_print = current_time
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            self.update_connection_quality()
            
            print("\n" + "="*60)
            print(f"üéØ REAL-TIME FEATURES (Msg #{self.message_count})")
            print("="*60)
            
            # –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∏—á–∏
            print(f"üìä Order Book Imbalance: {features['order_book_imbalance']:.3f}")
            print(f"üìè Spread: {features['spread_percent']:.6f}%")
            print(f"üìà Cumulative Delta: {features['cumulative_delta']:.4f}")
            print(f"üí∞ Funding Rate: {features['funding_rate']:.8f}")
            print(f"üîÑ Trades: {features['buy_trades']} buy / {features['sell_trades']} sell")
            print(f"üíµ Current Price: {features['current_price']:.1f}")
            print(f"üåä Volatility: {features['volatility']:.4f}%")
            
            print(f"\nü§ñ BASELINE STRATEGY:")
            print(f"   Decision: {strategy_result['decision']}")
            print(f"   Confidence: {strategy_result['confidence']:.1f}%")
            print(f"   Composite Score: {strategy_result['composite_score']:.3f}")
            print(f"   Market Regime: {strategy_result['market_regime']}")
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø-3 —Å–∏–≥–Ω–∞–ª–∞
            if strategy_result['signals']:
                print(f"   Top Signals:")
                for signal in strategy_result['signals'][:3]:
                    print(f"     {signal}")
            
            print(f"\nüìä DATA COLLECTION STATS:")
            print(f"   Messages: {self.stats['messages_received']}")
            print(f"   Features: {self.stats['features_processed']}")
            print(f"   Data Quality: {self.stats['connection_quality']}")
            print(f"   Last Update: {time.time() - self.stats['last_successful_update']:.1f}s ago")
            
            # –°—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–∏–ø–∞–º
            print(f"   Data Status:")
            for data_type, last_update in self.last_update_time.items():
                age = current_time - last_update
                status = "‚úÖ" if age < 5 else "‚ö†Ô∏è" if age < 10 else "‚ùå"
                print(f"     {data_type}: {status} ({age:.1f}s)")
            
            print("="*60 + "\n")
    
    def update_connection_quality(self):
        """–û—Ü–µ–Ω–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        current_time = time.time()
        time_since_last_update = current_time - self.stats['last_successful_update']
        
        if time_since_last_update < 5:
            self.stats['connection_quality'] = "EXCELLENT"
        elif time_since_last_update < 10:
            self.stats['connection_quality'] = "GOOD" 
        elif time_since_last_update < 20:
            self.stats['connection_quality'] = "POOR"
        else:
            self.stats['connection_quality'] = "DISCONNECTED"
    
    def on_error(self, ws, error):
        print(f"‚ùå WebSocket error: {error}")
        self.reconnect_attempts += 1
        
        if self.reconnect_attempts > self.max_reconnect_attempts:
            print("‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è")
            return
    
    def on_close(self, ws, close_status_code, close_msg):
        print(f"üîå WebSocket closed: {close_status_code} - {close_msg}")
        # –ê–≤—Ç–æ–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
        if self.reconnect_attempts <= self.max_reconnect_attempts:
            delay = min(30, 2 ** self.reconnect_attempts)
            print(f"üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {delay} —Å–µ–∫—É–Ω–¥...")
            time.sleep(delay)
            self.start()
        else:
            print("‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è")
    
    def on_open(self, ws):
        print(f"üîå WebSocket connected at {datetime.now()}")
        self.connection_start_time = time.time()
        self.reconnect_attempts = 0
        self.stats['connection_quality'] = "CONNECTED"
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì –î–õ–Ø –ü–û–î–ü–ò–°–ö–ò
        for channel in config.data.CHANNELS:
            subscribe_msg = {
                "op": "subscribe",
                "args": [
                    {
                        "channel": channel,
                        "instId": config.data.SYMBOL  # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì
                    }
                ]
            }
            ws.send(json.dumps(subscribe_msg))
            print(f"üì° Subscribed to: {channel} for {config.data.SYMBOL}")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        current_time = time.time()
        for data_type in self.last_update_time.keys():
            self.last_update_time[data_type] = current_time
    
    def get_connection_stats(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        current_time = time.time()
        uptime = current_time - self.connection_start_time if self.connection_start_time > 0 else 0
        
        return {
            'uptime_seconds': uptime,
            'messages_received': self.stats['messages_received'],
            'features_processed': self.stats['features_processed'],
            'connection_quality': self.stats['connection_quality'],
            'data_quality_issues': self.stats['data_quality_issues'],
            'reconnect_attempts': self.reconnect_attempts
        }
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
        print(f"üöÄ Starting data collector... (attempt {self.reconnect_attempts + 1})")
        
        try:
            self.ws = websocket.WebSocketApp(
                config.data.WS_URL,  # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì
                on_message=self.on_message,
                on_error=self.on_error, 
                on_close=self.on_close,
                on_open=self.on_open
            )
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º SSL –∫–æ–Ω—Ç–µ–∫—Å—Ç
            ssl_defaults = ssl.create_default_context()
            ssl_defaults.check_hostname = False
            ssl_defaults.verify_mode = ssl.CERT_NONE
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            self.ws_thread = threading.Thread(
                target=lambda: self.ws.run_forever(
                    sslopt={"cert_reqs": ssl.CERT_NONE, "check_hostname": False}
                )
            )
            self.ws_thread.daemon = True
            self.ws_thread.start()
            print("‚úÖ Data collector started successfully")
            
        except Exception as e:
            print(f"‚ùå Failed to start data collector: {e}")
            self.reconnect_attempts += 1
            if self.reconnect_attempts <= self.max_reconnect_attempts:
                time.sleep(config.data.RECONNECT_DELAY)  # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì
                self.start()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
data_collector = OKXDataCollector()


===== data_logger.py =====


# data_logger.py
import csv
import os
import time
from datetime import datetime
import pandas as pd
from config import config

class DataLogger:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        self.raw_data_file = "data/raw_data_backup.csv"
        self.setup_data_files()
        self.logged_count = 0
        self.last_log_time = 0
        
        # üîß –û–ß–ï–ù–¨ –ö–û–†–û–¢–ö–ò–ô –ò–ù–¢–ï–†–í–ê–õ
        self.log_interval = 2  # –í—Å–µ–≥–æ 2 —Å–µ–∫—É–Ω–¥—ã!
        
        self.max_records = config.data.MAX_RECORDS
        
        self.anomaly_count = 0
        self.last_data_quality_check = 0
        self.data_quality_stats = {
            'total_attempted': 0,
            'successful_logs': 0,
            'anomalies_detected': 0,
            'last_quality_report': 0
        }
        
    def setup_data_files(self):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ñ–∞–π–ª—ã –¥–∞–Ω–Ω—ã—Ö"""
        os.makedirs("data", exist_ok=True)
        
        if not os.path.exists(self.data_file):
            with open(self.data_file, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    'timestamp', 'order_book_imbalance', 'spread_percent',
                    'cumulative_delta', 'funding_rate', 'buy_trades',
                    'sell_trades', 'total_trades', 'current_price',
                    'volatility', 'target', 'data_quality'
                ])
            print("üìÅ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
        
        if not os.path.exists(self.raw_data_file):
            with open(self.raw_data_file, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    'timestamp', 'order_book_imbalance', 'spread_percent',
                    'cumulative_delta', 'funding_rate', 'buy_trades',
                    'sell_trades', 'total_trades', 'current_price',
                    'volatility', 'target', 'log_type'
                ])
            print("üìÅ –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª –¥–ª—è —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
    
    def safe_csv_value(self, value):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è CSV"""
        if value is None:
            return ''
        str_value = str(value)
        if ',' in str_value or '\n' in str_value or '\r' in str_value or '"' in str_value:
            return '"' + str_value.replace('"', '""') + '"'
        return str_value
    
    def is_valid_features(self, features):
        """üîß –°–£–ü–ï–†-–ú–Ø–ì–ö–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –í–°–ï"""
        try:
            self.data_quality_stats['total_attempted'] += 1
            
            # üîß –¢–û–õ–¨–ö–û –°–ê–ú–´–ï –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–ï–†–ö–ò
            price = features.get('current_price', 0)
            if price <= 0 or price > 500000:
                return False
                
            # üîß –í–°–ï –û–°–¢–ê–õ–¨–ù–û–ï –ü–†–ò–ù–ò–ú–ê–ï–ú –ë–ï–ó –ü–†–û–í–ï–†–û–ö
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            if self.data_quality_stats['total_attempted'] <= 10:
                print(f"üíæ ACCEPTING #{self.data_quality_stats['total_attempted']}: price={price}")
            
            return True  # üîß –ü–†–ò–ù–ò–ú–ê–ï–ú –í–°–ï!
            
        except Exception as e:
            return False
    
    def is_noisy_data(self, features):
        """üîß –û–ß–ï–ù–¨ –ú–Ø–ì–ö–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —à—É–º"""
        try:
            price = features.get('current_price', 0)
            return price <= 0  # üîß –¢–æ–ª—å–∫–æ –ø–æ–ª–Ω—ã–π –∫—Ä–∞—Ö
        except:
            return False
    
    def calculate_data_quality_score(self, features):
        """–ü—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞"""
        return 80  # üîß –í—Å–µ–≥–¥–∞ –≤—ã—Å–æ–∫–∞—è –æ—Ü–µ–Ω–∫–∞
    
    def log_raw_data(self, features):
        """–õ–æ–≥–∏—Ä—É–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ"""
        try:
            row_data = [
                self.safe_csv_value(features.get('timestamp', '')),
                self.safe_csv_value(features.get('order_book_imbalance', 0)),
                self.safe_csv_value(features.get('spread_percent', 0)),
                self.safe_csv_value(features.get('cumulative_delta', 0)),
                self.safe_csv_value(features.get('funding_rate', 0)),
                self.safe_csv_value(features.get('buy_trades', 0)),
                self.safe_csv_value(features.get('sell_trades', 0)),
                self.safe_csv_value(features.get('total_trades', 0)),
                self.safe_csv_value(features.get('current_price', 0)),
                self.safe_csv_value(features.get('volatility', 0)),
                self.safe_csv_value(features.get('target', 0)),
                'raw'
            ]
            
            with open(self.raw_data_file, 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(row_data)
        except:
            pass
    
    def log_features(self, features):
        """–û—Å–Ω–æ–≤–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        try:
            current_time = time.time()
            
            # –í—Å–µ–≥–¥–∞ –ª–æ–≥–∏—Ä—É–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
            self.log_raw_data(features)
            
            # üîß –ú–Ø–ì–ö–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø
            if not self.is_valid_features(features):
                self.data_quality_stats['anomalies_detected'] += 1
                return
            
            # üîß –ß–ê–°–¢–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï (2 —Å–µ–∫—É–Ω–¥—ã)
            if current_time - self.last_log_time < self.log_interval:
                return
                
            self.last_log_time = current_time
            self.logged_count += 1
            self.data_quality_stats['successful_logs'] += 1
            
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            row_data = [
                self.safe_csv_value(features.get('timestamp', '')),
                self.safe_csv_value(features.get('order_book_imbalance', 0)),
                self.safe_csv_value(features.get('spread_percent', 0)),
                self.safe_csv_value(features.get('cumulative_delta', 0)),
                self.safe_csv_value(features.get('funding_rate', 0)),
                self.safe_csv_value(features.get('buy_trades', 0)),
                self.safe_csv_value(features.get('sell_trades', 0)),
                self.safe_csv_value(features.get('total_trades', 0)),
                self.safe_csv_value(features.get('current_price', 0)),
                self.safe_csv_value(features.get('volatility', 0)),
                self.safe_csv_value(features.get('target', 0)),
                self.safe_csv_value(80)  # –í—Å–µ–≥–¥–∞ –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
            ]
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª
            with open(self.data_file, 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(row_data)
            
            # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
            target_val = features.get('target', 0)
            if target_val != 0:
                symbol = "üü¢" if target_val == 1 else "üî¥"
                text = "LONG" if target_val == 1 else "SHORT"
                print(f"üíæ {symbol} SAVED #{self.logged_count}: target={text}")
            elif self.logged_count % 10 == 0:
                print(f"üíæ ‚ö™ SAVED #{self.logged_count}: HOLD record")
                
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
data_logger = DataLogger()


===== data_monitor.py =====


# data_monitor.py
import os
import csv
from datetime import datetime, timedelta
import time
import pandas as pd
import numpy as np

class DataMonitor:
    def __init__(self):
        self.data_file = "data/training_data.csv"
        self.raw_data_file = "data/raw_data_backup.csv"
        self.last_check_time = 0
        self.check_interval = 30  # üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        
    def check_data_progress(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π"""
        if not os.path.exists(self.data_file):
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'NO_DATA',
                'data_quality_score': 0,
                'recent_activity': 'NO_ACTIVITY'
            }
        
        try:
            df = pd.read_csv(self.data_file)
            total_records = len(df)
            
            # üîß –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–ª–æ–Ω–∫–∏ target
            if 'target' not in df.columns:
                return {
                    'total_records': total_records,
                    'labeled_records': 0,
                    'target_distribution': {},
                    'data_quality': 'NO_TARGET',
                    'data_quality_score': 0,
                    'recent_activity': 'COLLECTING'
                }
            
            # –†–∞–∑–º–µ—á–µ–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ (–Ω–µ–Ω—É–ª–µ–≤–æ–π target)
            labeled_mask = df['target'].notna() & (df['target'] != 0)
            labeled_records = len(df[labeled_mask])
            
            # üîß –ù–û–í–û–ï: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target —Å –ø—Ä–æ—Ü–µ–Ω—Ç–∞–º–∏
            target_dist = {}
            if labeled_records > 0:
                target_counts = df[labeled_mask]['target'].value_counts()
                for target_val, count in target_counts.items():
                    percentage = (count / labeled_records) * 100
                    target_dist[int(target_val)] = {
                        'count': count,
                        'percentage': percentage
                    }
            
            # üîß –ù–û–í–û–ï: –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
            quality_score = self.calculate_data_quality(df)
            
            # üîß –ù–û–í–û–ï: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
            recent_activity = self.check_recent_activity(df)
            
            # –û–±—â–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
            if labeled_records == 0 and total_records > 0:
                quality = 'COLLECTING'
            elif labeled_records < 50:
                quality = 'MINIMAL'
            elif labeled_records < 200:
                quality = 'GOOD'
            else:
                quality = 'EXCELLENT'
                
            return {
                'total_records': total_records,
                'labeled_records': labeled_records,
                'target_distribution': target_dist,
                'data_quality': quality,
                'data_quality_score': quality_score,
                'recent_activity': recent_activity,
                'feature_stats': self.get_feature_stats(df)
            }
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {e}")
            return {
                'total_records': 0,
                'labeled_records': 0,
                'target_distribution': {},
                'data_quality': 'ERROR',
                'data_quality_score': 0,
                'recent_activity': 'ERROR'
            }
    
    def calculate_data_quality(self, df):
        """üîß –ù–û–í–û–ï: –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –æ–±—â–∏–π –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            score = 0
            max_score = 100
            
            # –ù–∞–ª–∏—á–∏–µ –¥–∞–Ω–Ω—ã—Ö
            if len(df) > 0:
                score += 20
            
            # –ù–∞–ª–∏—á–∏–µ —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            if 'target' in df.columns:
                labeled_count = len(df[df['target'].notna() & (df['target'] != 0)])
                if labeled_count > 0:
                    score += 30
                    # –ë–æ–Ω—É—Å –∑–∞ –±–∞–ª–∞–Ω—Å –∫–ª–∞—Å—Å–æ–≤
                    if labeled_count >= 50:
                        target_counts = df[df['target'] != 0]['target'].value_counts()
                        if len(target_counts) >= 2:
                            balance_score = min(target_counts) / max(target_counts) * 20
                            score += balance_score
            
            # –ö–∞—á–µ—Å—Ç–≤–æ —Ñ–∏—á
            feature_quality = self.assess_feature_quality(df)
            score += feature_quality
            
            return min(max_score, score)
            
        except Exception as e:
            return 0
    
    def assess_feature_quality(self, df):
        """üîß –ù–û–í–û–ï: –û—Ü–µ–Ω–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Ñ–∏—á"""
        score = 0
        important_features = ['order_book_imbalance', 'spread_percent', 'cumulative_delta']
        
        for feature in important_features:
            if feature in df.columns:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –Ω–∞–ª–∏—á–∏–µ NaN
                nan_ratio = df[feature].isna().sum() / len(df)
                if nan_ratio < 0.1:  # –ú–µ–Ω—å—à–µ 10% NaN
                    score += 10
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏—Å–ø–µ—Ä—Å–∏—é (–Ω–µ –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)
                if df[feature].nunique() > 10:
                    score += 5
        
        return min(30, score)
    
    def check_recent_activity(self, df):
        """üîß –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            if 'timestamp' not in df.columns or len(df) == 0:
                return 'UNKNOWN'
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º timestamp –≤ datetime
            df['datetime'] = pd.to_datetime(df['timestamp'])
            latest_record = df['datetime'].max()
            time_diff = datetime.now() - latest_record
            
            if time_diff < timedelta(minutes=2):
                return 'ACTIVE'
            elif time_diff < timedelta(minutes=5):
                return 'SLOW'
            elif time_diff < timedelta(minutes=10):
                return 'STALLED'
            else:
                return 'INACTIVE'
                
        except Exception as e:
            return 'UNKNOWN'
    
    def get_feature_stats(self, df):
        """üîß –ù–û–í–û–ï: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ñ–∏—á–∞–º"""
        stats = {}
        feature_columns = ['order_book_imbalance', 'spread_percent', 'cumulative_delta', 'volatility']
        
        for feature in feature_columns:
            if feature in df.columns:
                feature_data = df[feature].dropna()
                if len(feature_data) > 0:
                    stats[feature] = {
                        'min': float(feature_data.min()),
                        'max': float(feature_data.max()),
                        'mean': float(feature_data.mean()),
                        'std': float(feature_data.std()),
                        'count': len(feature_data)
                    }
        
        return stats
    
    def get_raw_data_stats(self):
        """üîß –ù–û–í–û–ï: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—ã—Ä—ã–º –¥–∞–Ω–Ω—ã–º"""
        if not os.path.exists(self.raw_data_file):
            return {'total_raw_records': 0, 'raw_vs_processed': 0}
        
        try:
            raw_df = pd.read_csv(self.raw_data_file)
            processed_df = pd.read_csv(self.data_file) if os.path.exists(self.data_file) else pd.DataFrame()
            
            raw_count = len(raw_df)
            processed_count = len(processed_df) if not processed_df.empty else 0
            
            conversion_rate = (processed_count / raw_count * 100) if raw_count > 0 else 0
            
            return {
                'total_raw_records': raw_count,
                'raw_vs_processed': conversion_rate
            }
        except Exception as e:
            return {'total_raw_records': 0, 'raw_vs_processed': 0}
    
    def print_progress_report(self):
        """–í—ã–≤–æ–¥–∏—Ç —É–ª—É—á—à–µ–Ω–Ω—ã–π –æ—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ"""
        progress = self.check_data_progress()
        raw_stats = self.get_raw_data_stats()
        
        print("\n" + "="*70)
        print("üìä –ü–û–î–†–û–ë–ù–´–ô –û–¢–ß–ï–¢ –û –°–ë–û–†–ï –î–ê–ù–ù–´–•")
        print("="*70)
        
        # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        print(f"üìÅ –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {progress['total_records']}")
        print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {progress['labeled_records']}")
        print(f"üìà –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality']} ({progress['data_quality_score']}/100)")
        print(f"üîÑ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: {progress['recent_activity']}")
        
        # üîß –ù–û–í–û–ï: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        print(f"üìã –°—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {raw_stats['total_raw_records']}")
        print(f"üìä –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –æ–±—É—á–∞—é—â–∏–µ: {raw_stats['raw_vs_processed']:.1f}%")
        
        # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target
        if progress['target_distribution']:
            print(f"\nüéØ –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï TARGET:")
            for target_val, info in progress['target_distribution'].items():
                symbol = "üî¥" if target_val == -1 else "üü¢" if target_val == 1 else "‚ö™"
                print(f"   {symbol} Target {target_val}: {info['count']} –∑–∞–ø–∏—Å–µ–π ({info['percentage']:.1f}%)")
        
        # üîß –ù–û–í–û–ï: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ñ–∏—á
        if progress['feature_stats']:
            print(f"\nüìà –°–¢–ê–¢–ò–°–¢–ò–ö–ê –§–ò–ß:")
            for feature, stats in list(progress['feature_stats'].items())[:3]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø-3
                print(f"   {feature}:")
                print(f"      min={stats['min']:.4f}, max={stats['max']:.4f}")
                print(f"      mean={stats['mean']:.4f} ¬± {stats['std']:.4f}")
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        print(f"\nüí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
        if progress['data_quality'] == 'NO_DATA':
            print("   ‚Ä¢ –ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö")
        elif progress['data_quality'] == 'COLLECTING':
            print("   ‚Ä¢ –î–∞–Ω–Ω—ã–µ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è, target —Å–∫–æ—Ä–æ –ø–æ—è–≤–∏—Ç—Å—è")
        elif progress['data_quality'] == 'MINIMAL':
            records_needed = 50 - progress['labeled_records']
            print(f"   ‚Ä¢ –°–æ–±–µ—Ä–∏—Ç–µ –µ—â–µ {records_needed} —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
        elif progress['data_quality'] == 'GOOD':
            print("   ‚Ä¢ –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏!")
            if progress['labeled_records'] < 200:
                print("   ‚Ä¢ –î–ª—è –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–±–µ—Ä–∏—Ç–µ 200+ —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π")
        elif progress['data_quality'] == 'EXCELLENT':
            print("   ‚Ä¢ –û—Ç–ª–∏—á–Ω—ã–π –æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö! –ú–æ–¥–µ–ª—å –¥–æ–ª–∂–Ω–∞ —Ö–æ—Ä–æ—à–æ –æ–±—É—á–∏—Ç—å—Å—è")
        
        # üîß –ù–û–í–û–ï: –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ –∫–∞—á–µ—Å—Ç–≤–µ
        if progress['recent_activity'] in ['SLOW', 'STALLED']:
            print(f"   ‚ö†Ô∏è  –ù–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö: {progress['recent_activity']}")
        
        if progress['data_quality_score'] < 50:
            print(f"   ‚ö†Ô∏è  –ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality_score']}/100")
        
        print("="*70)
    
    def check_model_readiness(self):
        """üîß –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏"""
        progress = self.check_data_progress()
        
        requirements = {
            'min_labeled_records': 30,
            'min_quality_score': 40,
            'require_multiple_classes': True
        }
        
        issues = []
        
        if progress['labeled_records'] < requirements['min_labeled_records']:
            issues.append(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {progress['labeled_records']}/{requirements['min_labeled_records']}")
        
        if progress['data_quality_score'] < requirements['min_quality_score']:
            issues.append(f"–ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality_score']}/{requirements['min_quality_score']}")
        
        if requirements['require_multiple_classes'] and len(progress['target_distribution']) < 2:
            issues.append("–ù–µ–æ–±—Ö–æ–¥–∏–º—ã –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ –º–∏–Ω–∏–º—É–º –¥–ª—è 2 –∫–ª–∞—Å—Å–æ–≤ (LONG/SHORT)")
        
        is_ready = len(issues) == 0
        
        return {
            'is_ready': is_ready,
            'issues': issues,
            'progress': progress
        }

def monitor_continuous():
    """–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º"""
    monitor = DataMonitor()
    
    print("üöÄ –ó–ê–ü–£–°–ö –ü–†–û–î–í–ò–ù–£–¢–û–ì–û –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –î–ê–ù–ù–´–•...")
    print("üí° –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥")
    print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
    
    iteration = 0
    
    try:
        while True:
            iteration += 1
            
            # üîß –ù–û–í–û–ï: –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –æ–±—É—á–µ–Ω–∏—é
            if iteration % 3 == 0:  # –ö–∞–∂–¥—ã–µ 3 –∏—Ç–µ—Ä–∞—Ü–∏–∏ (90 —Å–µ–∫—É–Ω–¥)
                readiness = monitor.check_model_readiness()
                if readiness['is_ready']:
                    print("\nüéâ –î–ê–ù–ù–´–ï –ì–û–¢–û–í–´ –î–õ–Ø –û–ë–£–ß–ï–ù–ò–Ø –ú–û–î–ï–õ–ò!")
                    print("üí° –ó–∞–ø—É—Å—Ç–∏—Ç–µ: python train_model.py")
                elif iteration % 6 == 0:  # –ö–∞–∂–¥—ã–µ 6 –∏—Ç–µ—Ä–∞—Ü–∏–π
                    print(f"\nüîç –ü–†–û–í–ï–†–ö–ê –ì–û–¢–û–í–ù–û–°–¢–ò:")
                    for issue in readiness['issues']:
                        print(f"   ‚ùå {issue}")
            
            monitor.print_progress_report()
            time.sleep(30)
            
    except KeyboardInterrupt:
        print("\nüõë –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

if __name__ == "__main__":
    monitor_continuous()


===== feature_engine.py =====


# feature_engine.py
from datetime import datetime, timedelta
import time
import numpy as np
from config import config

class FeatureEngine:
    def __init__(self):
        self.cumulative_delta = 0
        self.trade_counts = {'buy': 0, 'sell': 0}
        self.price_history = []
        self.feature_history = []
        self.last_update_time = 0
        self.update_interval = 1
        self.last_history_debug = 0
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        self.target_horizon = config.data.TARGET_HORIZON
        self.target_threshold = config.data.TARGET_THRESHOLD
        self.volatility_window = config.data.VOLATILITY_WINDOW
        
        self.trade_history = []
        self.ob_debug_shown = False
        
    def calculate_order_book_imbalance(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç imbalance –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0.5
                
            book = order_book_data[0]
            
            if 'bids' not in book or 'asks' not in book:
                return 0.5
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0.5
                
            bids = book['bids']
            asks = book['asks']
            
            bid_levels = min(len(bids), 3)
            ask_levels = min(len(asks), 3)
            
            if bid_levels == 0 or ask_levels == 0:
                return 0.5
            
            valid_bids = [bid for bid in bids[:bid_levels] if len(bid) >= 2 and float(bid[1]) > 0]
            valid_asks = [ask for ask in asks[:ask_levels] if len(ask) >= 2 and float(ask[1]) > 0]
            
            if not valid_bids or not valid_asks:
                return 0.5
            
            bid_volume = sum(float(bid[1]) for bid in valid_bids)
            ask_volume = sum(float(ask[1]) for ask in valid_asks)
            
            total_volume = bid_volume + ask_volume
            if total_volume == 0:
                return 0.5
                
            imbalance = bid_volume / total_volume
            imbalance = max(0.01, min(0.99, imbalance))
            
            return imbalance
            
        except Exception as e:
            return 0.5
    
    def calculate_spread(self, order_book_data):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–ø—Ä–µ–¥"""
        try:
            if not order_book_data or len(order_book_data) == 0:
                return 0.1
                
            book = order_book_data[0]
            
            if 'bids' not in book or 'asks' not in book:
                return 0.1
            if len(book['bids']) == 0 or len(book['asks']) == 0:
                return 0.1
            
            if len(book['bids'][0]) < 1 or len(book['asks'][0]) < 1:
                return 0.1
                
            best_bid = float(book['bids'][0][0])
            best_ask = float(book['asks'][0][0])
            
            if best_bid <= 0 or best_ask <= 0:
                return 0.1
                
            if best_bid >= best_ask:
                return 0.1
                
            spread = best_ask - best_bid
            mid_price = (best_bid + best_ask) / 2
            spread_percent = (spread / mid_price) * 100
            
            if spread_percent < 0 or spread_percent > 1.0:
                return 0.1
                
            return spread_percent
            
        except Exception as e:
            return 0.1
    
    def update_cumulative_delta(self, trade_data):
        """Rolling delta –∑–∞ 20 —Å–µ–∫—É–Ω–¥"""
        try:
            current_time = time.time()
            
            for trade in trade_data:
                if 'side' in trade and 'sz' in trade:
                    try:
                        size = float(trade['sz'])
                        sign = 1 if trade['side'] == 'buy' else -1
                        self.trade_history.append((current_time, sign * size))
                        
                        if trade['side'] == 'buy':
                            self.trade_counts['buy'] += 1
                        else:
                            self.trade_counts['sell'] += 1
                    except (ValueError, TypeError):
                        continue
            
            self.trade_history = [(ts, vol) for ts, vol in self.trade_history 
                                 if current_time - ts <= 20]
            
            self.cumulative_delta = sum(vol for ts, vol in self.trade_history)
            
            return self.cumulative_delta
            
        except Exception as e:
            return self.cumulative_delta
    
    def calculate_volatility(self):
        """–†–∞—Å—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏"""
        try:
            if len(self.price_history) < 2:
                return 0
                
            prices = [dp['price'] for dp in self.price_history[-self.volatility_window:]]
            if len(prices) < 2:
                return 0
                
            returns = []
            for i in range(1, len(prices)):
                if prices[i-1] != 0:
                    ret = (prices[i] - prices[i-1]) / prices[i-1]
                    returns.append(ret)
            
            if len(returns) < 2:
                return 0
                
            volatility = np.std(returns) * 100
            return volatility
            
        except Exception as e:
            return 0
    
    def extract_funding_rate(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç funding rate"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            ticker = ticker_data[0]
            return float(ticker.get('fundingRate', 0))
        except Exception as e:
            return 0
    
    def get_current_price(self, ticker_data):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É"""
        try:
            if not ticker_data or len(ticker_data) == 0:
                return 0
            
            ticker = ticker_data[0]
            
            price_fields = ['last', 'lastPrice', 'close', 'markPx']
            for field in price_fields:
                if field in ticker and ticker[field]:
                    price = float(ticker[field])
                    if 1000 < price < 200000:
                        return price
            
            if 'askPx' in ticker and 'bidPx' in ticker:
                if ticker['askPx'] and ticker['bidPx']:
                    bid = float(ticker['bidPx'])
                    ask = float(ticker['askPx'])
                    if bid > 0 and ask > 0 and bid < ask:
                        price = (bid + ask) / 2
                        if 1000 < price < 200000:
                            return price
            
            return 0
            
        except Exception as e:
            return 0
    
    def calculate_target(self, current_price, future_price):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç target —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø–æ—Ä–æ–≥–æ–º"""
        if current_price == 0 or future_price == 0:
            return 0
            
        price_change = (future_price - current_price) / current_price * 100
        
        if price_change > self.target_threshold:
            return 1
        elif price_change < -self.target_threshold:
            return -1
        else:
            return 0

    def should_update_features(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ñ–∏—á–∏"""
        current_time = time.time()
        if current_time - self.last_update_time >= self.update_interval:
            self.last_update_time = current_time
            return True
        return False

    def update_price_history(self, current_price, features):
        """–û–ë–ù–û–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç target"""
        if current_price == 0:
            return None
            
        current_time = datetime.now()
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Ç–æ—á–∫—É –≤ –∏—Å—Ç–æ—Ä–∏—é
        current_data_point = {
            'timestamp': current_time,
            'price': current_price,
            'features': features.copy(),
            'target_calculated': False,
            'target': 0
        }
        self.price_history.append(current_data_point)
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        if len(self.price_history) > config.data.FEATURE_WINDOW:
            self.price_history = self.price_history[-config.data.FEATURE_WINDOW:]
        
        # üîß –†–ê–°–°–ß–ò–¢–´–í–ê–ï–ú TARGET –î–õ–Ø –°–¢–ê–†–´–• –¢–û–ß–ï–ö
        targets_calculated = 0
        features_with_target = None
        
        for old_data_point in self.price_history:
            if old_data_point['target_calculated']:
                continue
                
            # –í—ã—á–∏—Å–ª—è–µ–º –≤—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –¥–ª—è —ç—Ç–æ–≥–æ target
            time_passed = (current_time - old_data_point['timestamp']).total_seconds()
            
            if time_passed >= self.target_horizon:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∫–∞–∫ –±—É–¥—É—â—É—é –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ target
                future_price = current_price
                old_price = old_data_point['price']
                
                target = self.calculate_target(old_price, future_price)
                old_data_point['target'] = target
                old_data_point['target_calculated'] = True
                old_data_point['features']['target'] = target
                targets_calculated += 1
                
                # üîß –í–û–ó–í–†–ê–©–ê–ï–ú –ü–ï–†–í–£–Æ –ñ–ï –¢–û–ß–ö–£ –° TARGET
                if target != 0 and features_with_target is None:
                    features_with_target = old_data_point['features']
                
                # –õ–æ–≥–∏—Ä—É–µ–º —Ä–∞—Å—á–µ—Ç—ã target
                price_change = (future_price - old_price) / old_price * 100
                if target != 0:
                    print(f"üéØ CALCULATED TARGET: {target} (change: {price_change:.4f}%, "
                          f"time: {time_passed:.1f}s, old: {old_price:.1f}, current: {future_price:.1f})")
        
        # –î–µ–±–∞–≥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥
        current_timestamp = time.time()
        if current_timestamp - self.last_history_debug > 15:
            self.last_history_debug = current_timestamp
            
            total_points = len(self.price_history)
            calculated_targets = sum(1 for p in self.price_history if p['target_calculated'])
            non_zero_targets = sum(1 for p in self.price_history if p.get('target', 0) != 0)
            
            print(f"\nüìà PRICE HISTORY: {total_points} points, "
                  f"{calculated_targets} targets calculated, "
                  f"{non_zero_targets} non-zero targets")
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ targets
            if non_zero_targets > 0:
                long_count = sum(1 for p in self.price_history if p.get('target', 0) == 1)
                short_count = sum(1 for p in self.price_history if p.get('target', 0) == -1)
                print(f"üìä TARGET DISTRIBUTION: LONG={long_count}, SHORT={short_count}")
        
        return features_with_target

    def get_all_features(self, order_book_data, trade_data, ticker_data):
        """üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∏—á–∏ —Å target –µ—Å–ª–∏ –µ—Å—Ç—å"""
        if not self.should_update_features():
            if self.price_history:
                # üîß –í–û–ó–í–†–ê–©–ê–ï–ú –ü–û–°–õ–ï–î–ù–ò–ï –§–ò–ß–ò –° TARGET
                latest_features = self.price_history[-1]['features'].copy()
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–π target
                if 'target' in latest_features and latest_features['target'] != 0:
                    return latest_features
                return self.price_history[-1]['features']
            else:
                return self.create_empty_features()
        
        self.update_cumulative_delta(trade_data)
        
        current_price = self.get_current_price(ticker_data)
        
        if current_price == 0:
            if self.price_history:
                return self.price_history[-1]['features']
            else:
                return self.create_empty_features()
        
        volatility = self.calculate_volatility()
        
        features = {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': self.calculate_order_book_imbalance(order_book_data),
            'spread_percent': self.calculate_spread(order_book_data),
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': self.extract_funding_rate(ticker_data),
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': current_price,
            'volatility': volatility,
            'target': 0
        }
        
        # üîß –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –æ–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏—á–∏ –° TARGET
        updated_features = self.update_price_history(current_price, features)
        
        # üîß –ï–°–õ–ò –ï–°–¢–¨ –§–ò–ß–ò –° TARGET - –í–û–ó–í–†–ê–©–ê–ï–ú –ò–•
        if updated_features is not None:
            return updated_features
        
        # üîß –ò–ù–ê–ß–ï –ò–©–ï–ú –õ–Æ–ë–´–ï –§–ò–ß–ò –° TARGET –í –ò–°–¢–û–†–ò–ò
        for data_point in reversed(self.price_history):
            if 'target' in data_point['features'] and data_point['features']['target'] != 0:
                return data_point['features']
        
        # üîß –ï–°–õ–ò TARGET'–û–í –ù–ï–¢ - –í–û–ó–í–†–ê–©–ê–ï–ú –¢–ï–ö–£–©–ò–ï
        return features

    def create_empty_features(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø—É—Å—Ç—ã–µ —Ñ–∏—á–∏"""
        return {
            'timestamp': datetime.now().isoformat(),
            'order_book_imbalance': 0.5,
            'spread_percent': 0.1,
            'cumulative_delta': self.cumulative_delta,
            'funding_rate': 0,
            'buy_trades': self.trade_counts['buy'],
            'sell_trades': self.trade_counts['sell'],
            'total_trades': self.trade_counts['buy'] + self.trade_counts['sell'],
            'current_price': 0,
            'volatility': 0,
            'target': 0
        }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
feature_engine = FeatureEngine()


===== live_predictor.py =====


# live_predictor.py
import joblib
import pandas as pd
from datetime import datetime
import time
import os
from data_collector import data_collector
from feature_engine import feature_engine
from config import config  # üîß –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–£–Æ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ

class LivePredictor:
    def __init__(self):
        self.model = None
        
        # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ –ú–û–î–ï–õ–ò
        self.model_path = config.model.MODEL_PATH
        self.feature_columns = config.model.FEATURE_COLUMNS
        self.min_probability = config.model.MIN_PROBABILITY
        self.confidence_threshold = config.model.CONFIDENCE_THRESHOLD
        
        self.prediction_count = 0
        self.load_model()
        
    def load_model(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –º–æ–¥–µ–ª—å —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π"""
        try:
            # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–£–¢–¨ –ò–ó –ö–û–ù–§–ò–ì–ê
            if not os.path.exists(self.model_path):
                print(f"‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {self.model_path}")
                print("üí° –ó–∞–ø—É—Å—Ç–∏—Ç–µ train_model.py —Å–Ω–∞—á–∞–ª–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏")
                return
                
            self.model = joblib.load(self.model_path)
            print(f"‚úÖ –ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {self.model_path}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∞—Å—Å—ã –º–æ–¥–µ–ª–∏
            if hasattr(self.model, 'classes_'):
                print(f"üéØ –ö–ª–∞—Å—Å—ã –º–æ–¥–µ–ª–∏: {self.model.classes_}")
                
            # üîß –ü–†–û–í–ï–†–Ø–ï–ú –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –ü–†–ò–ó–ù–ê–ö–û–í
            if hasattr(self.model, 'feature_names_in_'):
                expected_features = list(self.model.feature_names_in_)
                available_features = self.feature_columns
                missing_features = set(expected_features) - set(available_features)
                if missing_features:
                    print(f"‚ö†Ô∏è  –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –≤ –º–æ–¥–µ–ª–∏ –µ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–∏, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –∫–æ–Ω—Ñ–∏–≥–µ: {missing_features}")
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏: {e}")
            self.model = None
    
    def make_prediction(self, features):
        """–î–µ–ª–∞–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞
            if self.model is None:
                return {
                    'prediction': 0,
                    'probability': 0,
                    'confidence': "0%",
                    'timestamp': datetime.now().strftime("%H:%M:%S"),
                    'error': 'Model not loaded'
                }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ —Ñ–∏—á
            if features.get('current_price', 0) == 0:
                return {
                    'prediction': 0,
                    'probability': 0,
                    'confidence': "0%",
                    'timestamp': datetime.now().strftime("%H:%M:%S"),
                    'error': 'Invalid features'
                }
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–¥–µ–ª–∏
            feature_data = []
            for feature in self.feature_columns:
                if feature in features:
                    feature_data.append(features[feature])
                else:
                    print(f"‚ö†Ô∏è  –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫: {feature}")
                    feature_data.append(0)  # –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω—É–ª–µ–º
            
            X = pd.DataFrame([feature_data], columns=self.feature_columns)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ NaN
            if X.isnull().any().any():
                print("‚ùå NaN values in features")
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Ñ–∏—á–∏ —á–∏—Å–ª–æ–≤—ã–µ
            for col in self.feature_columns:
                if col in X.columns:
                    X[col] = pd.to_numeric(X[col], errors='coerce')
            
            # –ó–∞–ø–æ–ª–Ω—è–µ–º NaN –µ—Å–ª–∏ –µ—Å—Ç—å
            X = X.fillna(0)
            
            # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
            prediction = self.model.predict(X)[0]
            probabilities = self.model.predict_proba(X)[0]
            
            # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ confidence
            confidence = max(probabilities) * 100
            predicted_class = prediction
            
            self.prediction_count += 1
            
            # üîß –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏
            if self.prediction_count <= 3 or self.prediction_count % 20 == 0:
                print(f"\nüîç ML DIAGNOSTIC (Prediction #{self.prediction_count}):")
                print(f"   Features: imbalance={features.get('order_book_imbalance', 0):.3f}, "
                      f"delta={features.get('cumulative_delta', 0):.1f}")
                if hasattr(self.model, 'classes_'):
                    for i, cls in enumerate(self.model.classes_):
                        prob = probabilities[i] * 100
                        print(f"   Class {cls}: {prob:.1f}%")
                print(f"   Final prediction: {predicted_class}, confidence: {confidence:.1f}%")
                
                # üîß –ü–†–û–í–ï–†–ö–ê –ü–û–†–û–ì–ê –£–í–ï–†–ï–ù–ù–û–°–¢–ò
                if confidence < self.confidence_threshold * 100:
                    print(f"   ‚ö†Ô∏è  –ù–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å ({confidence:.1f}% < {self.confidence_threshold * 100:.1f}%)")
            
            return {
                'prediction': predicted_class,
                'probability': max(probabilities),
                'confidence': f"{confidence:.1f}%",
                'timestamp': datetime.now().strftime("%H:%M:%S"),
                'probabilities': probabilities.tolist() if hasattr(probabilities, 'tolist') else probabilities,
                'raw_confidence': confidence
            }
            
        except Exception as e:
            print(f"‚ùå Prediction error: {e}")
            import traceback
            traceback.print_exc()
            return {
                'prediction': 0,
                'probability': 0,
                'confidence': "0%",
                'timestamp': datetime.now().strftime("%H:%M:%S"),
                'error': str(e)
            }
    
    def check_model_health(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –º–æ–¥–µ–ª–∏"""
        if self.model is None:
            return "‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞"
        
        try:
            # –¢–µ—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
            test_features = {
                'order_book_imbalance': 0.6,
                'spread_percent': 0.01,
                'cumulative_delta': 5,
                'funding_rate': 0.0001,
                'buy_trades': 10,
                'sell_trades': 5,
                'total_trades': 15,
                'volatility': 0.5
            }
            
            test_pred = self.make_prediction(test_features)
            if test_pred and 'error' not in test_pred:
                confidence = test_pred.get('raw_confidence', 0)
                if confidence >= self.confidence_threshold * 100:
                    return f"‚úÖ –ú–æ–¥–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç (—Ç–µ—Å—Ç: {test_pred['prediction']}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.1f}%)"
                else:
                    return f"‚ö†Ô∏è  –ú–æ–¥–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.1f}%"
            else:
                return "‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è"
                
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–æ–¥–µ–ª–∏: {e}"
    
    def start_live_predictions(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
        print("üéØ LIVE ML PREDICTIONS STARTED...")
        print("=" * 60)
        
        # üîß –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò
        print(f"üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–∏:")
        print(f"   –ú–æ–¥–µ–ª—å: {self.model_path}")
        print(f"   –ü—Ä–∏–∑–Ω–∞–∫–∏: {len(self.feature_columns)}")
        print(f"   –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å: {self.min_probability}")
        print(f"   –ü–æ—Ä–æ–≥ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏: {self.confidence_threshold}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–¥–µ–ª—å
        health_status = self.check_model_health()
        print(f"üîß Model Health: {health_status}")
        
        if self.model is None:
            print("‚ùå –ù–µ –º–æ–≥—É –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è - –º–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            print("üí° –ó–∞–ø—É—Å—Ç–∏—Ç–µ: python train_model.py")
            return
        
        last_print_time = 0
        consecutive_holds = 0
        low_confidence_count = 0
        
        while True:
            current_time = time.time()
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ —Ñ–∏—á–∏
            features = feature_engine.get_all_features(
                data_collector.order_book_data,
                data_collector.trade_data, 
                data_collector.ticker_data
            )
            
            # –î–µ–ª–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
            if current_time - last_print_time >= 10:
                last_print_time = current_time
                
                prediction = self.make_prediction(features)
                
                if prediction and 'error' not in prediction:
                    # üîß –ü–†–û–í–ï–†–ö–ê –ú–ò–ù–ò–ú–ê–õ–¨–ù–û–ô –í–ï–†–û–Ø–¢–ù–û–°–¢–ò
                    probability = prediction.get('probability', 0)
                    raw_confidence = prediction.get('raw_confidence', 0)
                    
                    if probability < self.min_probability:
                        prediction['prediction'] = 0  # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ HOLD
                        low_confidence_count += 1
                    else:
                        low_confidence_count = 0
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –∏ —Å–∏–º–≤–æ–ª –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    if prediction['prediction'] == 1:
                        symbol = "üü¢ LONG"
                        color = "\033[92m"  # –ó–µ–ª–µ–Ω—ã–π
                        consecutive_holds = 0
                    elif prediction['prediction'] == -1:
                        symbol = "üî¥ SHORT" 
                        color = "\033[91m"  # –ö—Ä–∞—Å–Ω—ã–π
                        consecutive_holds = 0
                    else:
                        symbol = "‚ö™ HOLD"
                        color = "\033[90m"  # –°–µ—Ä—ã–π
                        consecutive_holds += 1
                    
                    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –º–Ω–æ–≥–∏—Ö HOLD –ø–æ–¥—Ä—è–¥
                    hold_warning = ""
                    if consecutive_holds > 5:
                        hold_warning = " ‚ö†Ô∏è MANY HOLDS"
                    
                    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –Ω–∏–∑–∫–æ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
                    confidence_warning = ""
                    if probability < self.min_probability:
                        confidence_warning = " üìâ LOW CONFIDENCE"
                    
                    # –í—ã–≤–æ–¥ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    print(f"{color}üéØ [{prediction['timestamp']}] {symbol} | Confidence: {prediction['confidence']}{hold_warning}{confidence_warning}")
                    print(f"   üìä Imbalance: {features.get('order_book_imbalance', 0):.3f} | "
                          f"Delta: {features.get('cumulative_delta', 0):.1f} | "
                          f"Volatility: {features.get('volatility', 0):.3f}%")
                    
                    # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –±–µ–π–∑–ª–∞–π–Ω–æ–º
                    from baseline_strategy import baseline_strategy
                    baseline = baseline_strategy.analyze_signal(features)
                    print(f"   ü§ñ Baseline: {baseline['decision']} ({baseline['confidence']:.0f}%)")
                    
                    # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è –Ω–µ–Ω—É–ª–µ–≤—ã—Ö –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
                    if prediction['prediction'] != 0 and 'probabilities' in prediction:
                        probs = prediction['probabilities']
                        if hasattr(self.model, 'classes_'):
                            prob_str = " | ".join([f"C{cls}:{p*100:.1f}%" 
                                                for cls, p in zip(self.model.classes_, probs)])
                            print(f"   üìà Probabilities: {prob_str}")
                    
                    print("-" * 60)
                else:
                    error_msg = prediction.get('error', 'Unknown error') if prediction else 'No prediction'
                    print(f"‚ùå Prediction failed: {error_msg}")
                    print("-" * 60)
            
            time.sleep(1)

if __name__ == "__main__":
    predictor = LivePredictor()
    predictor.start_live_predictions()


===== main.py =====


# main.py
from data_collector import data_collector
from data_monitor import DataMonitor
from live_predictor import LivePredictor
import time
import argparse
import sys
import os
from datetime import datetime

class QuantumBot:
    def __init__(self):
        self.monitor = DataMonitor()
        self.predictor = None
        self.operation_mode = "DATA_COLLECTION"  # DATA_COLLECTION, TRADING, MONITORING
        self.start_time = datetime.now()
        self.performance_stats = {
            'uptime': 0,
            'data_points_collected': 0,
            'predictions_made': 0,
            'last_health_check': 0
        }
        
    def print_banner(self):
        """–ü–µ—á–∞—Ç–∞–µ—Ç –±–∞–Ω–Ω–µ—Ä –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
        print("\n" + "="*70)
        print("üöÄ QUANTUM TRADING BOT v2.0")
        print("="*70)
        print("üìä –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã:")
        print("   ‚Ä¢ DATA_COLLECTION - –°–±–æ—Ä –∏ —Ä–∞–∑–º–µ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö")
        print("   ‚Ä¢ TRADING - –¢–æ—Ä–≥–æ–≤–ª—è —Å ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è–º–∏") 
        print("   ‚Ä¢ MONITORING - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–µ–∑ —Ç–æ—Ä–≥–æ–≤–ª–∏")
        print("="*70)
        
    def parse_arguments(self):
        """–ü–∞—Ä—Å–∏—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
        parser = argparse.ArgumentParser(description='Quantum Trading Bot')
        parser.add_argument('--mode', type=str, default='data', 
                          choices=['data', 'trade', 'monitor', 'predict'],
                          help='–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: data (—Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö), trade (—Ç–æ—Ä–≥–æ–≤–ª—è), monitor (–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥), predict (–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è)')
        parser.add_argument('--model', type=str, default='models/quant_model.pkl',
                          help='–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –º–æ–¥–µ–ª–∏')
        parser.add_argument('--symbol', type=str, default='BTC-USDT-SWAP',
                          help='–¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞')
        parser.add_argument('--verbose', action='store_true',
                          help='–ü–æ–¥—Ä–æ–±–Ω—ã–π –≤—ã–≤–æ–¥')
        
        return parser.parse_args()
    
    def setup_operation_mode(self, mode):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã"""
        mode_map = {
            'data': 'DATA_COLLECTION',
            'trade': 'TRADING', 
            'monitor': 'MONITORING',
            'predict': 'PREDICTION'
        }
        
        self.operation_mode = mode_map.get(mode, 'DATA_COLLECTION')
        
        print(f"\nüéØ –£–°–¢–ê–ù–û–í–õ–ï–ù –†–ï–ñ–ò–ú: {self.operation_mode}")
        
        if self.operation_mode == 'TRADING':
            print("üí∞ –†–ï–ñ–ò–ú –¢–û–†–ì–û–í–õ–ò: –ë–æ—Ç –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∏ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å")
            self.predictor = LivePredictor()
        elif self.operation_mode == 'PREDICTION':
            print("üîÆ –†–ï–ñ–ò–ú –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–ô: –¢–æ–ª—å–∫–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –±–µ–∑ —Ç–æ—Ä–≥–æ–≤–ª–∏")
            self.predictor = LivePredictor()
        elif self.operation_mode == 'MONITORING':
            print("üìä –†–ï–ñ–ò–ú –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê: –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –∞–Ω–∞–ª–∏–∑ –±–µ–∑ —Ç–æ—Ä–≥–æ–≤–ª–∏")
        else:
            print("üìà –†–ï–ñ–ò–ú –°–ë–û–†–ê –î–ê–ù–ù–´–•: –ê–∫—Ç–∏–≤–Ω—ã–π —Å–±–æ—Ä –∏ —Ä–∞–∑–º–µ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö")
    
    def check_system_health(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ —Å–∏—Å—Ç–µ–º—ã"""
        current_time = time.time()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ 60 —Å–µ–∫—É–Ω–¥
        if current_time - self.performance_stats['last_health_check'] < 60:
            return True
            
        self.performance_stats['last_health_check'] = current_time
        self.performance_stats['uptime'] = (datetime.now() - self.start_time).total_seconds()
        
        issues = []
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
        try:
            conn_stats = data_collector.get_connection_stats()
            if conn_stats['connection_quality'] in ['POOR', 'DISCONNECTED']:
                issues.append(f"–ü–ª–æ—Ö–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {conn_stats['connection_quality']}")
                
            if conn_stats['data_quality_issues'] > 10:
                issues.append(f"–ú–Ω–æ–≥–æ –ø—Ä–æ–±–ª–µ–º —Å –∫–∞—á–µ—Å—Ç–≤–æ–º –¥–∞–Ω–Ω—ã—Ö: {conn_stats['data_quality_issues']}")
                
        except Exception as e:
            issues.append(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–±–æ—Ä—â–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö: {e}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–¥–µ–ª—å –≤ —Ä–µ–∂–∏–º–µ —Ç–æ—Ä–≥–æ–≤–ª–∏
        if self.operation_mode in ['TRADING', 'PREDICTION'] and self.predictor:
            try:
                health_status = self.predictor.check_model_health()
                if "‚ùå" in health_status:
                    issues.append(f"–ü—Ä–æ–±–ª–µ–º—ã —Å –º–æ–¥–µ–ª—å—é: {health_status}")
            except Exception as e:
                issues.append(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–æ–¥–µ–ª–∏: {e}")
        
        # –í—ã–≤–æ–¥–∏–º –æ—Ç—á–µ—Ç –æ –∑–¥–æ—Ä–æ–≤—å–µ
        if issues:
            print(f"\n‚ö†Ô∏è  –ü–†–û–ë–õ–ï–ú–´ –°–ò–°–¢–ï–ú–´:")
            for issue in issues:
                print(f"   ‚Ä¢ {issue}")
            return False
        else:
            if current_time % 300 < 60:  # –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
                print(f"\n‚úÖ –°–ò–°–¢–ï–ú–ê –í –ù–û–†–ú–ï (–∞–ø—Ç–∞–π–º: {self.performance_stats['uptime']:.0f}—Å)")
            return True
    
    def run_data_collection_mode(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ä–µ–∂–∏–º —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
        print("\nüìà –ó–ê–ü–£–°–ö –°–ë–û–†–ê –î–ê–ù–ù–´–•...")
        print("üí° –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è ML –º–æ–¥–µ–ª–∏")
        print("üí° –î–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–º–µ—á–∞—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 8 —Å–µ–∫—É–Ω–¥")
        print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
        
        last_progress_check = 0
        last_health_check = 0
        
        try:
            while True:
                current_time = time.time()
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
                if current_time - last_progress_check > 120:
                    self.monitor.print_progress_report()
                    last_progress_check = current_time
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ —Å–∏—Å—Ç–µ–º—ã –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
                if current_time - last_health_check > 60:
                    self.check_system_health()
                    last_health_check = current_time
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
                readiness = self.monitor.check_model_readiness()
                if readiness['is_ready'] and current_time % 300 < 60:  # –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
                    print("\nüéâ –î–ê–ù–ù–´–ï –ì–û–¢–û–í–´ –î–õ–Ø –û–ë–£–ß–ï–ù–ò–Ø!")
                    print("üí° –ó–∞–ø—É—Å—Ç–∏—Ç–µ: python train_model.py")
                    print("üí° –ò–ª–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ —Å —Ä–µ–∂–∏–º–æ–º --mode=predict\n")
                
                time.sleep(5)
                
        except KeyboardInterrupt:
            print("\nüõë –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    def run_prediction_mode(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ä–µ–∂–∏–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π"""
        print("\nüîÆ –ó–ê–ü–£–°–ö –†–ï–ñ–ò–ú–ê –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–ô...")
        print("üí° ML –º–æ–¥–µ–ª—å –¥–µ–ª–∞–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏")
        print("üí° –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å baseline —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π")
        print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
        
        if not self.predictor or self.predictor.model is None:
            print("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞! –°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –º–æ–¥–µ–ª—å:")
            print("   python train_model.py")
            return
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        progress = self.monitor.check_data_progress()
        print(f"üìä –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–Ω–∞—è –Ω–∞ {progress['labeled_records']} –∑–∞–ø–∏—Å—è—Ö")
        print(f"üéØ –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {progress['data_quality']}\n")
        
        try:
            self.predictor.start_live_predictions()
        except KeyboardInterrupt:
            print("\nüõë –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
    
    def run_trading_mode(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ä–µ–∂–∏–º —Ç–æ—Ä–≥–æ–≤–ª–∏"""
        print("\nüí∞ –ó–ê–ü–£–°–ö –†–ï–ñ–ò–ú–ê –¢–û–†–ì–û–í–õ–ò...")
        print("‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: –≠—Ç–æ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º!")
        print("üí° –ë–æ—Ç –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∏ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å")
        print("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫!")
        print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
        
        # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        response = input("üîí –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –∑–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–ª–∏ (–≤–≤–µ–¥–∏—Ç–µ 'YES' –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è): ")
        if response != 'YES':
            print("üõë –¢–æ—Ä–≥–æ–≤–ª—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
            return
        
        if not self.predictor or self.predictor.model is None:
            print("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞! –°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –º–æ–¥–µ–ª—å:")
            print("   python train_model.py")
            return
        
        print("üöÄ –ó–ê–ü–£–°–ö –¢–û–†–ì–û–í–õ–ò...")
        # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ç–æ—Ä–≥–æ–≤—ã–º API
        print("üìà –¢–æ—Ä–≥–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –≤ –±—É–¥—É—â–∏—Ö –≤–µ—Ä—Å–∏—è—Ö")
        print("üí° –ü–æ–∫–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–∂–∏–º --mode=predict –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è\n")
        
        try:
            while True:
                # –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
                time.sleep(10)
                print("üîß –¢–æ—Ä–≥–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ...")
        except KeyboardInterrupt:
            print("\nüõë –¢–æ—Ä–≥–æ–≤–ª—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    
    def run_monitoring_mode(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ä–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        print("\nüìä –ó–ê–ü–£–°–ö –†–ï–ñ–ò–ú–ê –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê...")
        print("üí° –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö –∏ —Å–∏—Å—Ç–µ–º—ã –±–µ–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π")
        print("üí° –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C\n")
        
        try:
            iteration = 0
            while True:
                iteration += 1
                
                # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                self.monitor.print_progress_report()
                
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞–∂–¥—ã–µ 5 –∏—Ç–µ—Ä–∞—Ü–∏–π
                if iteration % 5 == 0:
                    print("\nüîß –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:")
                    conn_stats = data_collector.get_connection_stats()
                    print(f"   üì° –°–æ–æ–±—â–µ–Ω–∏–π: {conn_stats['messages_received']}")
                    print(f"   üìä –§–∏—á –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {conn_stats['features_processed']}")
                    print(f"   üîó –ö–∞—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–∏: {conn_stats['connection_quality']}")
                    print(f"   ‚è±Ô∏è  –ê–ø—Ç–∞–π–º: {self.performance_stats['uptime']:.0f}—Å")
                
                time.sleep(30)
                
        except KeyboardInterrupt:
            print("\nüõë –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    def run(self):
        """–ì–ª–∞–≤–Ω—ã–π –º–µ—Ç–æ–¥ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
        args = self.parse_arguments()
        
        self.print_banner()
        self.setup_operation_mode(args.mode)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –≤ –ª—é–±–æ–º —Ä–µ–∂–∏–º–µ
        print("\nüîå –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –±–∏—Ä–∂–µ...")
        data_collector.start()
        
        # –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        time.sleep(3)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
        if self.operation_mode == 'TRADING':
            self.run_trading_mode()
        elif self.operation_mode == 'PREDICTION':
            self.run_prediction_mode()
        elif self.operation_mode == 'MONITORING':
            self.run_monitoring_mode()
        else:
            self.run_data_collection_mode()
    
    def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏"""
        print("\nüßπ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
        if hasattr(data_collector, 'ws'):
            data_collector.ws.close()
        print("‚úÖ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

def main():
    bot = QuantumBot()
    
    try:
        bot.run()
    except KeyboardInterrupt:
        print("\n\nüõë –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        import traceback
        traceback.print_exc()
    finally:
        bot.cleanup()

if __name__ == "__main__":
    main()


===== train_model.py =====


# train_model.py
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
from sklearn.utils import class_weight
import joblib
import os
import matplotlib.pyplot as plt
import seaborn as sns
from config import config  # üîß –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–£–Æ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ

def load_training_data():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π"""
    data_file = "data/training_data.csv"
    
    if not os.path.exists(data_file):
        print("‚ùå –§–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ.")
        return None
    
    try:
        df = pd.read_csv(data_file)
        print(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(df)} –∑–∞–ø–∏—Å–µ–π")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–ª–æ–Ω–∫–∏ target
        if 'target' not in df.columns:
            print("‚ùå –ö–æ–ª–æ–Ω–∫–∞ 'target' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∞–Ω–Ω—ã—Ö")
            return None
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        target_data = df['target'].dropna()
        if len(target_data) == 0:
            print("‚ùå –ù–µ—Ç —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (target). –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö.")
            return None
        
        print(f"üéØ –†–∞–∑–º–µ—á–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {len(target_data)}")
        
        return df
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return None

def detailed_data_analysis(df):
    """–î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö"""
    print("\nüîç –î–ï–¢–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó –î–ê–ù–ù–´–•:")
    
    # –£–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –±–µ–∑ target
    df_labeled = df.dropna(subset=['target'])
    df_labeled['target'] = df_labeled['target'].astype(int)
    
    # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target
    target_counts = df_labeled['target'].value_counts().sort_index()
    total_labeled = len(df_labeled)
    
    print(f"üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ target ({total_labeled} –∑–∞–ø–∏—Å–µ–π):")
    for target_val in [-1, 0, 1]:
        count = target_counts.get(target_val, 0)
        percentage = count / total_labeled * 100
        symbol = "üî¥" if target_val == -1 else "‚ö™" if target_val == 0 else "üü¢"
        print(f"   {symbol} Target {target_val}: {count} –∑–∞–ø–∏—Å–µ–π ({percentage:.1f}%)")
    
    # –ê–Ω–∞–ª–∏–∑ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    print(f"\nüìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤:")
    
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–ò–ó–ù–ê–ö–ò –ò–ó –ö–û–ù–§–ò–ì–ê
    feature_columns = config.model.FEATURE_COLUMNS
    
    for feature in feature_columns:
        if feature in df_labeled.columns:
            stats = df_labeled[feature].describe()
            print(f"   {feature}:")
            print(f"      min={stats['min']:.6f}, max={stats['max']:.6f}")
            print(f"      mean={stats['mean']:.6f}, std={stats['std']:.6f}")
            print(f"      non-zero: {(df_labeled[feature] != 0).sum()}/{len(df_labeled)}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    constant_features = []
    for feature in feature_columns:
        if feature in df_labeled.columns and df_labeled[feature].nunique() <= 1:
            constant_features.append(feature)
    
    if constant_features:
        print(f"‚ö†Ô∏è  –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏: {constant_features}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ —Å target
    print(f"\nüìä –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Å target:")
    for feature in feature_columns:
        if feature in df_labeled.columns:
            correlation = df_labeled[feature].corr(df_labeled['target'])
            print(f"   {feature}: {correlation:.3f}")
    
    return df_labeled

def create_baseline_model(df):
    """–°–æ–∑–¥–∞–µ—Ç –±–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–∞–≤–∏–ª"""
    print("\nü§ñ –ë–ï–ô–ó–õ–ê–ô–ù –ú–û–î–ï–õ–¨ (–ø—Ä–∞–≤–∏–ª–∞):")
    
    # –ü—Ä–∞–≤–∏–ª–æ 1: Imbalance
    df['baseline_imbalance'] = (df['order_book_imbalance'] > 0.6).astype(int)
    accuracy_imbalance = accuracy_score(df['target'] == 1, df['baseline_imbalance'])
    print(f"üìä Imbalance > 0.6 accuracy: {accuracy_imbalance:.3f}")
    
    # –ü—Ä–∞–≤–∏–ª–æ 2: Delta
    df['baseline_delta'] = (df['cumulative_delta'] > 0).astype(int)
    accuracy_delta = accuracy_score(df['target'] == 1, df['baseline_delta'])
    print(f"üìà Delta > 0 accuracy: {accuracy_delta:.3f}")
    
    # –ü—Ä–∞–≤–∏–ª–æ 3: Combined
    df['baseline_combined'] = ((df['order_book_imbalance'] > 0.6) & 
                              (df['cumulative_delta'] > 0)).astype(int)
    accuracy_combined = accuracy_score(df['target'] == 1, df['baseline_combined'])
    print(f"üéØ Combined rule accuracy: {accuracy_combined:.3f}")
    
    # –ë–µ–π–∑–ª–∞–π–Ω –¥–ª—è –≤—Å–µ—Ö –∫–ª–∞—Å—Å–æ–≤
    baseline_majority = (df['target'] == 0).mean()
    print(f"üìä Majority class (HOLD) accuracy: {baseline_majority:.3f}")

def handle_class_imbalance(df):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∏—Å–±–∞–ª–∞–Ω—Å –∫–ª–∞—Å—Å–æ–≤"""
    print("\n‚öñÔ∏è  –û–ë–†–ê–ë–û–¢–ö–ê –î–ò–°–ë–ê–õ–ê–ù–°–ê –ö–õ–ê–°–°–û–í:")
    
    target_counts = df['target'].value_counts()
    print(f"–ò—Å—Ö–æ–¥–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: {target_counts.to_dict()}")
    
    # –í—ã—á–∏—Å–ª—è–µ–º –≤–µ—Å–∞ –∫–ª–∞—Å—Å–æ–≤
    class_weights = class_weight.compute_class_weight(
        class_weight='balanced',
        classes=np.array([-1, 0, 1]),
        y=df['target']
    )
    
    weight_dict = {-1: class_weights[0], 0: class_weights[1], 1: class_weights[2]}
    print(f"–í–µ—Å–∞ –∫–ª–∞—Å—Å–æ–≤: {weight_dict}")
    
    return weight_dict

def train_ml_model(df):
    """–û–±—É—á–∞–µ—Ç ML –º–æ–¥–µ–ª—å —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
    print("\nüß† –û–ë–£–ß–ï–ù–ò–ï ML –ú–û–î–ï–õ–ò...")
    
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–ò–ó–ù–ê–ö–ò –ò–ó –ö–û–ù–§–ò–ì–ê
    feature_columns = config.model.FEATURE_COLUMNS
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    missing_features = [f for f in feature_columns if f not in df.columns]
    if missing_features:
        print(f"‚ö†Ô∏è  –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏: {missing_features}")
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
        feature_columns = [f for f in feature_columns if f in df.columns]
    
    X = df[feature_columns]
    y = df['target']
    
    # –£–±–∏—Ä–∞–µ–º NaN
    mask = ~X.isna().any(axis=1)
    X = X[mask]
    y = y[mask]
    
    print(f"üìä –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è: {len(X)} –∑–∞–ø–∏—Å–µ–π")
    print(f"üéØ –ü—Ä–∏–∑–Ω–∞–∫–∏: {feature_columns}")
    
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ú–ò–ù–ò–ú–ê–õ–¨–ù–û–ï –ö–û–õ–ò–ß–ï–°–¢–í–û –ó–ê–ü–ò–°–ï–ô –ò–ó –ö–û–ù–§–ò–ì–ê
    if len(X) < config.model.MIN_TRAINING_RECORDS:
        print(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è. –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º {config.model.MIN_TRAINING_RECORDS}, —Å–µ–π—á–∞—Å: {len(X)}")
        return None
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∏—Å–±–∞–ª–∞–Ω—Å –∫–ª–∞—Å—Å–æ–≤
    class_weights = handle_class_imbalance(pd.DataFrame({'target': y}))
    
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–ê–†–ê–ú–ï–¢–†–´ –ú–û–î–ï–õ–ò –ò–ó –ö–û–ù–§–ò–ì–ê
    model_params = config.model.RANDOM_FOREST_PARAMS.copy()
    model_params['class_weight'] = class_weights
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ä—è–¥–∞–º–∏
    tscv = TimeSeriesSplit(n_splits=min(config.model.CROSS_VALIDATION_SPLITS, len(X) // 10))
    model = RandomForestClassifier(**model_params)
    
    # –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
    print("üìä –ó–∞–ø—É—Å–∫ –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏–∏...")
    scores = cross_val_score(model, X, y, cv=tscv, scoring='accuracy')
    print(f"üìä –ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è accuracy: {scores.mean():.3f} (+/- {scores.std() * 2:.3f})")
    
    # –û–±—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –º–æ–¥–µ–ª–∏
    model.fit(X, y)
    print("‚úÖ –ú–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–∞!")
    
    # –í–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    feature_importance = pd.DataFrame({
        'feature': feature_columns,
        'importance': model.feature_importances_
    }).sort_values('importance', ascending=False)
    
    print("\nüéØ –í–ê–ñ–ù–û–°–¢–¨ –ü–†–ò–ó–ù–ê–ö–û–í:")
    for _, row in feature_importance.iterrows():
        print(f"  {row['feature']}: {row['importance']:.3f}")
    
    # –î–µ—Ç–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –º–æ–¥–µ–ª–∏
    y_pred = model.predict(X)
    print(f"\nüìà –¢–æ—á–Ω–æ—Å—Ç—å –Ω–∞ –æ–±—É—á–∞—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö: {accuracy_score(y, y_pred):.3f}")
    
    # –ú–∞—Ç—Ä–∏—Ü–∞ –æ—à–∏–±–æ–∫
    cm = confusion_matrix(y, y_pred)
    print(f"üìä –ú–∞—Ç—Ä–∏—Ü–∞ –æ—à–∏–±–æ–∫:")
    print(f"   True -1: {cm[0]}")
    print(f"   True  0: {cm[1]}") 
    print(f"   True  1: {cm[2]}")
    
    return model, feature_columns

def save_model(model, feature_columns):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ"""
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–£–¢–ò –ò–ó –ö–û–ù–§–ò–ì–ê
    model_path = config.model.MODEL_PATH
    metadata_path = config.model.METADATA_PATH
    
    os.makedirs("models", exist_ok=True)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–¥–µ–ª—å
    joblib.dump(model, model_path)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    metadata = {
        'feature_columns': feature_columns,
        'model_type': config.model.MODEL_TYPE,
        'timestamp': pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
        'classes': model.classes_.tolist() if hasattr(model, 'classes_') else [],
        'training_records': len(model.estimators_[0].classes_) if hasattr(model, 'estimators_') else 0,
        'config_version': config.VERSION
    }
    joblib.dump(metadata, metadata_path)
    
    print(f"üíæ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {model_path}")
    print(f"üìù –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: {metadata_path}")
    print(f"üéØ –ö–ª–∞—Å—Å—ã –º–æ–¥–µ–ª–∏: {metadata['classes']}")
    print(f"üîß –í–µ—Ä—Å–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {metadata['config_version']}")

def plot_feature_importance(model, feature_columns):
    """–í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–æ–≤"""
    try:
        importance_df = pd.DataFrame({
            'feature': feature_columns,
            'importance': model.feature_importances_
        }).sort_values('importance', ascending=True)
        
        plt.figure(figsize=(10, 6))
        plt.barh(importance_df['feature'], importance_df['importance'])
        plt.xlabel('–í–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–∞')
        plt.title('–í–∞–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –≤ –º–æ–¥–µ–ª–∏')
        plt.tight_layout()
        plt.savefig('models/feature_importance.png', dpi=300, bbox_inches='tight')
        print("üìä –ì—Ä–∞—Ñ–∏–∫ –≤–∞–∂–Ω–æ—Å—Ç–∏ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: models/feature_importance.png")
        plt.close()
    except Exception as e:
        print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫: {e}")

def main():
    print("üöÄ –ó–ê–ü–£–°–ö –û–ë–£–ß–ï–ù–ò–Ø –ú–û–î–ï–õ–ò...")
    print(f"üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: {config.VERSION} ({config.ENVIRONMENT})")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    df = load_training_data()
    if df is None:
        return
    
    # –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö
    df_labeled = detailed_data_analysis(df)
    if df_labeled is None or len(df_labeled) == 0:
        print("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
        return
    
    # –ë–µ–π–∑–ª–∞–π–Ω –º–æ–¥–µ–ª—å
    create_baseline_model(df_labeled)
    
    # ML –º–æ–¥–µ–ª—å (–µ—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö)
    # üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –ú–ò–ù–ò–ú–ê–õ–¨–ù–û–ï –ö–û–õ–ò–ß–ï–°–¢–í–û –ó–ê–ü–ò–°–ï–ô –ò–ó –ö–û–ù–§–ò–ì–ê
    if len(df_labeled) >= config.model.MIN_TRAINING_RECORDS:
        print(f"\nüîß –û–±—É—á–µ–Ω–∏–µ –Ω–∞ {len(df_labeled)} –∑–∞–ø–∏—Å—è—Ö...")
        result = train_ml_model(df_labeled)
        if result:
            model, feature_columns = result
            save_model(model, feature_columns)
            plot_feature_importance(model, feature_columns)
            print("\nüéâ –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.")
            print(f"üí° –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–ø—É—Å—Ç–∏—Ç–µ: python main.py --mode=predict")
        else:
            print("‚ùå –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏")
    else:
        needed = config.model.MIN_TRAINING_RECORDS - len(df_labeled)
        print(f"üìä –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö. –ù—É–∂–Ω–æ –µ—â–µ {needed} –∑–∞–ø–∏—Å–µ–π (—Å–µ–π—á–∞—Å: {len(df_labeled)}/{config.model.MIN_TRAINING_RECORDS})")

if __name__ == "__main__":
    main()
